<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />








  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Code Me">
<meta property="og:url" content="http://zhangmhao.github.io/page/3/index.html">
<meta property="og:site_name" content="Code Me">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code Me">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> Code Me </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Code Me</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/04/02/停下來想一想-前端开发总结/" itemprop="url">
                停下來想一想-前端开发总结
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-04-02T00:00:00+08:00" content="2014-04-02">
            2014-04-02
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端开发/" itemprop="url" rel="index">
                  <span itemprop="name">前端开发</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>刚刚开始工作到现在已经快2年了，作为前端开发的新人，觉得这个行业有太多的东西要学习，无论是术，还是道，都足够我一段时间的学习。经过这一年半的前端开发，我学到了些什麽，目前的水平如何？在评估自己之前，我得问自己这样一个问题，什麽是前端开发？</p>
<h2 id="什麽是前端开发？">什麽是前端开发？</h2><p>个人的理解是一切与界面相关的都是前端，网站，webapp，手机App，车载系统，甚至是数据可眎化，这些看得见的东西都可以归类为前端。与实现语言，平台和设备无关。创造出高可用的人机交互界面是前端开发工程师的职责。如果将范围缩小到个人目前工作领域，我理解的前端开发就是使用Web标淮创建出高可用高性能的前端应用。<br>那为什麽我要做前端，而不是做数据库，不去做后端呢？这个问题我时至今日都不甚清楚，在问自己之前先问问自己另外一个问题，前端的价值在哪裡？</p>
<h2 id="前端的价值">前端的价值</h2><p>前端的价值，最常见的答案也许是：</p>
<ol>
<li>交互界面的实现</li>
<li>用户体验优化</li>
<li>性能优化</li>
</ol>
<p>第一点是前端工程师的主要工作职责，而第2和第3点也只是在第一点基础上的优化。这3点有其价值，但更多的是属于前端工程师的工作职责，而非价值所在。前端价值是什麽？前端是一个有界面的应用或者系统裡距离用户最近的一个层，而前端工程师同样是团队中离用户最近的人。</p>
<h4 id="对于团队的价值">对于团队的价值</h4><p>在团队中，前端工程师一般的工作就是，实现UE的设计稿，消费后端数据接口，起到衔接的作用。有了前端工程师，项目才得以并行开发，后端工程师专注于数据的处理，前端关注用户界面。效率得以提升。</p>
<h4 id="对于产品的价值">对于产品的价值</h4><p>产品要做活，就得像一个健康的生物体一样代谢。前端可以促进这种代谢循环当然，这就要求前端工程师是在做产品，而不是在做切图仔，UI实现工这种较为简单的工作。前端工程师，产品工程师，用户界面工程师(User Interface Engineer)，交互设计师，不要用这些职称给自己设限。 建议阅读克军的一个PPT「<a href="http://hikejun.com/blog/2013/11/16/%E8%BF%98%E5%8E%9F%E2%80%9C%E6%B4%BB%E2%80%9D%E7%9A%84%E8%AE%BE%E8%AE%A1/" target="_blank" rel="external">还原“活”的设计</a>」</p>
<p>这个是自己目前对前端价值目前的理解，水平有限，仅供参考</p>
<p>理清楚了一些基础的问题，现在来对自己个人进行一些评估。首先列出前端工程师的知识网，然后看看自己已有的知识，找出自己欠缺的知识点。</p>
<h2 id="前端工程师知识体系">前端工程师知识体系</h2><p>知识体系这裡参考朴灵的一个整理「<a href="https://github.com/JacksonTian/fks" target="_blank" rel="external">前端技能汇总</a>」</p>
<h2 id="个人知识体系">个人知识体系</h2><p><img src="data:image,local://1396347670901" alt="Alt text"></p>
<p>通过对比个人知识体系和业界知识体系，可以发现自己的差距。</p>
<h4 id="需要更加深入">需要更加深入</h4><ul>
<li>单元测试</li>
<li>计算机基础知识</li>
<li>交互设计</li>
<li>产品思维</li>
</ul>
<h4 id="目前未接触">目前未接触</h4><ul>
<li>前端技术<ul>
<li>Responsive Design, Less</li>
</ul>
</li>
</ul>
<h4 id="值得学习的项目和技术">值得学习的项目和技术</h4><ul>
<li>ECMAScript6</li>
<li>Angular</li>
<li>Sencha Touch</li>
<li>Bootstrap</li>
</ul>
<p>今年会投入时间在计算机基础知识的积累，捡起丢下的知识。另外学习ECMAScript6和Ruby，在开源项目学习方面，学习Angular,Bootstrap,Sencha Touch。对自己的要求是不能停留在使用阶段，而是吸收其优点，来提高自己的框架设计能力（学习这些开源项目，然后应用一些想法到自己维护的框架Com中, 该框架仅用于个人学习之用）</p>
<p>总之，感觉自己目前处于“术”的阶段，有术而无“道”。后面通过基础理论的学习，框架的编写。儘快练习出“道”</p>
<h2 id="工程化思考">工程化思考</h2><p>前端在许多佈道者的努力下，越来越多的人使用更加高效的工作流，得以将时间用在更重要的事物之上。前端工程化也开始受到了开发者的重视。那么我们所指的前端开发工作内容有哪些呢？</p>
<ul>
<li>开发<ul>
<li>设计（并非指UI设计，而是软件设计Software design）</li>
<li>切图</li>
<li>使用Web标淮(HTML,CSS,JS)实现界面交互</li>
</ul>
</li>
<li>测试</li>
<li>构建和部署</li>
<li>维护和监控</li>
</ul>
<p>从上面的工作内容可以看出，其实前端开发与其他软件开发并没有太过明显的区别，而缺少工程化和对基础理论的不重视可能是目前前端困境最主要的原因。先介绍一下个人理解的前端工程化：</p>
<ul>
<li>编码规范，开发淮则（模块化，组件化）目的是代码的高质量和可维护</li>
<li>开发框架</li>
<li>自动化 目的是提高软件开发效率，避免人为错误<ul>
<li>开发过程</li>
<li>打包部署过程</li>
</ul>
</li>
<li>测试（单元测试，集成测试）</li>
<li>文档：降低维护成本（时间，人力）</li>
</ul>
<p>布鲁克斯在《人月神话：软件项目管理之道（The Mythical Man-Month）》提到</p>
<blockquote>
<p>将没有银子弹（silverbullet）可解决，开发软件的困难是内生的，只能渐进式的改善。整体环境没有改变以前，唯一可能的解，是依靠人的素质，培养优秀的工程师。</p>
</blockquote>
<p>但是在前端开发领域，优秀前端工程师比例相对较少，那么如何保证产品质量呢？可以通过规范的限制，开发框架和工具的辅助，让前端工程师写出高性能，高质量的代码，进而提高开发效率，保证软件质量。</p>
<p>作为前端新人，以上只是我对前端工程化一些初级的想法。</p>
<h3 id="那么目前前端领域有那些工具可以帮我们实现工程化呢？">那么目前前端领域有那些工具可以帮我们实现工程化呢？</h3><ul>
<li>编码规范和开发淮则<br>每个团队都会有所不同，这个没有一个普世的标淮。</li>
<li>开发框架 <ul>
<li>模块化加载工具：seajs，requirejs</li>
<li>开发框架：Angular，Backbone</li>
</ul>
</li>
<li>自动化<ul>
<li>海量基于Node.js的工具,没有的你自己就可以编写</li>
<li>Yeoman 项目构建工具</li>
<li>Grunt,Gulp</li>
<li>Bower 前端依赖库自动化管理</li>
</ul>
</li>
<li>测试<ul>
<li>单元测试：QUnit, jasmine, mocha</li>
<li>集成测试：PhantomJS, slimerJS</li>
<li>持续集成：Travis</li>
</ul>
</li>
</ul>
<p>更多工具参考: <a href="http://html5ify.com/fks/" target="_blank" rel="external">Frontend Knowledge Structure</a></p>
<p>期待自己身上有的特质：低调务实、精工细琢，戒骄戒躁，犬儒主义让开一边，用数据说话，用严谨科学的论据来支撑你的观点，看清一部分技术本质，避免盲目跟风。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/03/26/w3c是什么/" itemprop="url">
                W3c是什么组织？
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-03-26T00:00:00+08:00" content="2014-03-26">
            2014-03-26
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端开发/" itemprop="url" rel="index">
                  <span itemprop="name">前端开发</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="这篇笔记是观看视频：Fluent_2013:_Lea_Verou,_Everything_You_Always_Wanted_to_Know_About_Web_Standards_之后的摘录">这篇笔记是观看视频：<a href="http://www.tudou.com/programs/view/E6NZ6retifQ/" target="_blank" rel="external">Fluent 2013: Lea Verou, Everything You Always Wanted to Know About Web Standards</a> 之后的摘录</h2><h4 id="W3C是做什么的？">W3C是做什么的？</h4><ul>
<li>规范并不是由W3C编写的，而是由工作组（Working Groups）编写</li>
<li>W3C制定规范制作的流程</li>
<li>协调各项进程，监督进度，安排会议（W3Conf, TPAC ）</li>
<li>制作工具和推广(Tool And Education)</li>
</ul>
<h4 id="什么是W3C工作组？">什么是W3C工作组？</h4><h5 id="人员组成：">人员组成：</h5><ul>
<li>浏览器厂商</li>
<li>网站</li>
<li>其他公司（例如HP,Adobe)</li>
</ul>
<p>例如css工作组，88％的是其他公司的人员，专家：5％，w3c工作人员: 6%</p>
<h4 id="工作组如何编写规范？">工作组如何编写规范？</h4><p>组员通过邮件组​​，IRC，Bug Tracker来进行工作，每一个工作组会有规范编辑(Spec Editor)，规范的编写<br>由这些编辑人员来进行编写规范。</p>
<p>常见名词：</p>
<ul>
<li>成熟度等级(Maturity Levels)</li>
<li>工作草案(Working Draft)</li>
<li>候选推荐(Candidate Recommendation)</li>
</ul>
<h4 id="如何成为一个标准？">如何成为一个标准？</h4><p>你有了一个想法，将想法提交给工作组，提议提交之后会有3种结果Rejected， Accepted，Forgotten<br>如果通过了​​，之后就会有进入”编辑草案（Editor’s draft）”阶段，这个时候还不能称之为规范(Spec)，<br>整个工作组的成员会审核这一份草案，然后就会得到一份First Public Working Draft (FPWD)，<br>这个的发布意味着规范已经开始成熟，但还不够稳定，浏览器厂商一般不会实现。然后就不停的迭代，<br>在某个时间点发布Last Call Working Draft，最后就进入Candidate Recommendation(CR),这个时候<br>代表规范已经非常成熟了，浏览器厂商会开始实现这些规范。<br>“提议推荐阶段”（Proposeed Recommendation）(PR),<br>接着最后的阶段就是“正式推荐”（Recommendation）</p>
<h4 id="我怎么跟上脚步？">我怎么跟上脚步？</h4><ul>
<li>加入邮件组，获取最新消息</li>
<li>阅读W3C站点</li>
<li>阅读webplatform.org</li>
<li><a href="http://uptodate.frontendrescue.org/" target="_blank" rel="external">HOW TO KEEP UP TO DATE ON FRONT-END TECHNOLOGIES</a></li>
</ul>
<h4 id="其他信息">其他信息</h4><ul>
<li>W3C一直都是保持免费的，这个和其他标准化组织ISO不同</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/03/25/切面编程/" itemprop="url">
                切面编程
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-03-25T00:00:00+08:00" content="2014-03-25">
            2014-03-25
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/编程理论/" itemprop="url" rel="index">
                  <span itemprop="name">编程理论</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>今天在实现COM的事件功能过程遇到了一个问题，由于子节点不能直接和父节点之外的节点通信，类似于Router，Logger的横切需求该如何实现呢？</p>
<h3 id="面向切面编程的定义">面向切面编程的定义</h3><p>将程序逻辑分成一个个的逻辑块，也就是关注点，而有部分关注点称之为横切关注点，指的是一些具有横越多个模块的行为，使用传统的软件开发方法不能够达到有效的模块化的一类特殊关注点。软件系统，可看作由一组关注点组成。其中，直接的业务关注点，是直切关注点。而为直切关注点提供服务的，就是横切关注点，例如日志、安全、持久化;</p>
<h3 id="一个需求之前的实现：">一个需求之前的实现：</h3><ol>
<li>点击列表项，触发router事件</li>
<li>根节点监听route事件，然后调用Router进行Dispatch</li>
</ol>
<p>但是由于Com框架的改进，决定不使用依赖于Dom节点的事件冒泡机制，导致节点之间无法跨级沟通。所以之前的实现对于现在的Com来讲是无效的。<br>Router是一种横切关注点，单又不合适用继承机制来实现</p>
<p>最简单的方式就是，单例, 然后在所有需要的地方引入依赖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = &#123;</span><br><span class="line">    route: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*更多的代码*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在需要的地方mixin router，然后该组件就具有了router的功能</span></span><br><span class="line"><span class="keyword">var</span> application = <span class="keyword">new</span> Application(&#123;</span><br><span class="line">    <span class="comment">/*Application config*/</span></span><br><span class="line">    uiEvents: &#123;</span><br><span class="line">        <span class="string">'click li'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> path = evt.currentTarget.data.path;</span><br><span class="line">            <span class="comment">//路由dispatch</span></span><br><span class="line">            router.route()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用javascript <code>mixin</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = &#123;</span><br><span class="line">    route: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/*更多的代码*/</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在需要的地方mixin router，然后该组件就具有了router的功能</span></span><br><span class="line"><span class="keyword">var</span> application = <span class="keyword">new</span> Application(&#123;</span><br><span class="line">    <span class="comment">/*Application config*/</span></span><br><span class="line">    uiEvents: &#123;</span><br><span class="line">        <span class="string">'click li'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> path = evt.currentTarget.data.path;</span><br><span class="line">            <span class="comment">//路由dispatch</span></span><br><span class="line">            app.route(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).mixin(router);</span><br></pre></td></tr></table></figure>
<p>这两种方桉是可行的。那么还有其他的方法吗？</p>
<p>而对于Com来讲，Router是一个功能组件，同时也是一个所有节点都会可能会需要到的功能。如果按照mixin的方式，或者单例的做法，无论如何都是在要在每一个都是要显示声明依赖。维护成本比较高。那么可以使用类似于注册一个组件的方式，然后在内部就可以通过注册的ID来取得所需的组件。这样子维护成本就降低了，起码不用在修改组件名层的时候一处处的修改引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> router = <span class="comment">/*Router的功能*/</span></span><br><span class="line"><span class="keyword">var</span> application = <span class="keyword">new</span> Application(&#123;</span><br><span class="line">    <span class="comment">/*Application config*/</span></span><br><span class="line">    uiEvents: &#123;</span><br><span class="line">        <span class="string">'click li'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> path = evt.currentTarget.data.path;</span><br><span class="line">            <span class="comment">//路由dispatch</span></span><br><span class="line">            app.route(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).cross(<span class="string">'Router'</span>, router);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面的代码是Application中的某一个组件 Cell的定义*/</span></span><br><span class="line">Cell = Com.extend(&#123;</span><br><span class="line">    uiEvents: &#123;</span><br><span class="line">        <span class="comment">//点击触发Router跳转</span></span><br><span class="line">        <span class="string">'click'</span>: <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> path = evt.currentTarget.data.id;</span><br><span class="line">            <span class="comment">//同样通过cross接口拿到Router组件，然后直接使用</span></span><br><span class="line">            <span class="keyword">this</span>.cross(<span class="string">'Router'</span>).route(<span class="string">'Cell/'</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>这种东西有无通过Aspect来实现，需要继续思考。</strong></p>
<h3 id="todo">todo</h3><ul>
<li>学习dojo的aspect，阅读源码</li>
</ul>
<p>###参考</p>
<ol>
<li><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="external">http://en.wikipedia.org/wiki/Aspect-oriented_programming</a></li>
<li><a href="http://en.wikipedia.org/wiki/Modularity_(programming" target="_blank" rel="external">http://en.wikipedia.org/wiki/Modularity_(programming</a>)</li>
<li><a href="http://www.infoq.com/cn/articles/zwb-dojo-aop" target="_blank" rel="external">dojo1.7功能介绍：面向方面编程（AOP）功能与原理</a></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/03/24/javascript内存优化/" itemprop="url">
                javascript内存优化
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-03-24T00:00:00+08:00" content="2014-03-24">
            2014-03-24
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端开发/" itemprop="url" rel="index">
                  <span itemprop="name">前端开发</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>在阅读「<a href="http://lifemap.in/javascript-memory-optimize/" target="_blank" rel="external">javascript内存优化</a>」文章时候几个收获，是在目前的编码中没有仔细考虑到的</p>
<h3 id="手工解除变量引用，特别是全局变量（因为全局变量不会被回收，应该儘可能避免使用全局变量）">手工解除变量引用，特别是全局变量（因为全局变量不会被回收，应该儘可能避免使用全局变量）</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">data</span> = &#123; <span class="comment">/* some big data */</span> &#125;;</span><br><span class="line"><span class="comment">// blah blah blah</span></span><br><span class="line"><span class="built_in">data</span> = <span class="built_in">null</span>;</span><br></pre></td></tr></table></figure>
<h3 id="回调函数的一种专业介绍">回调函数的一种专业介绍</h3><p>回调函数一种后续传递风格(Continuation Passing Style,CPS)的技术，这种风格的程序编写将函数的业务重点从返回值转移到回调函数中去。而且其相比闭包的好处也不少</p>
<ul>
<li>如果传入的参数是基础类型（如字符串、数值），回调函数中传入的形参就会是複製值，业务代码使用完毕以后，更容易被回收；</li>
<li>通过回调，我们除了可以完成同步的请求外，还可以用在异步编程中，这也就是现在非常流行的一种编写风格；</li>
<li>回调函数自身通常也是临时的匿名函数，一旦请求函数执行完毕，回调函数自身的引用就会被解除，自身也得到回收。</li>
</ul>
<h3 id="循环事件绑定两种闭包传入参数方式,_对于大数据出离">循环事件绑定两种闭包传入参数方式, 对于大数据出离</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Case 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">  btns[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">      output.innerText += <span class="string">'Clicked '</span> + events[index];</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Case 2</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line">第二个方桉传入的参数是当前循环下标，而后者是直接传入相应的事件对象。事实上，后者更适合在大量数据应用的时候，因为在 JavaScript 的函数式编程中，函数调用时传入的参数是基本类型对象，那麽在函数体内得到的形参会是一个複製值，这样这个值就被当作一个局部变量定义在函数体的作用域内，在完成事件绑定之后就可以对events变量进行手工解除引用，以减轻外层作用域中的内存佔用了。而且当某个元素被删除时，相应的事件监听函数、事件对象、闭包函数也随之被销毁回收。</span><br><span class="line">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">  btns[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">      output.innerText += <span class="string">'Clicked '</span> + event;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(events[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="闭包的另外一种视角">闭包的另外一种视角</h3><p>让外层作用域访问内层作用域的技术便是闭包(Closure)。实现的技术原理：通过高阶函数的应用</p>
<h3 id="内存检查工具">内存检查工具</h3><ul>
<li>chrome开发工具：Profiles</li>
<li>在 Node.js 中，我们可以使用 node-heapdump 和 node-memwatch 模块进行内存检查。</li>
</ul>
<h3 id="参考">参考</h3><ol>
<li><a href="http://lifemap.in/javascript-memory-optimize/" target="_blank" rel="external">javascript内存优化</a></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/03/07/组件化与复杂系统/" itemprop="url">
                组件化与复杂系统
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-03-07T00:00:00+08:00" content="2014-03-07">
            2014-03-07
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/学习研究/" itemprop="url" rel="index">
                  <span itemprop="name">学习研究</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>第一次接触复杂系统的概念是在一个TED讲座（<a href="evernote:///view/3937825/s36/10cba1c3-4db0-45ec-a534-f87040364ba8/10cba1c3-4db0-45ec-a534-f87040364ba8/" target="_blank" rel="external">复杂系统</a>）中，马上就被这个美妙的东西捕获了。作者在演讲中讲「Complexity is the result of simple rules of interaction」，局部的简单逻辑形成整体的智能。 第一个问题：为什么个体之间的简单交互能够形成整体的智能呢？  观察自然界，动物界中的鸟群，鱼群，这两种动物并没有高级的智能，但是群体通过多个节点之间的简单交互，可以形成整体的复杂智能。观察数字世界，计算机是由一个个的晶体管构成的，​​单一个晶体管只有两种状态：低电平和高电平，对应于0和1。但是由数亿个晶体管组成的微处理器却具有了相当的智能。如果你看过「三体」，你此时定会想起小说中出现的人列计算机。事实证明，无论是现实物理世界，还是数字世界都存在一定智能的复杂系统。</p>
<h3 id="什么是复杂系统？">什么是复杂系统？</h3><p>在<a href="http://www.swarmagents.cn/complex/intro/articles.htm" target="_blank" rel="external">这篇文章</a>中是这样定义复杂系统「复杂系统是具有中等数目基于局部信息做出行动的智能性、自适应性主体的系统，复杂系统分为无组织，有组织两种」文中列出了「复杂系统具有的三个特征」</p>
<h4 id="1-_中等大小数目的主体">1. 中等大小数目的主体</h4><h4 id="2-_智能性和自适应性">2. 智能性和自适应性</h4><p>系统内的元素遵循一定的规则，根据环境和收集到的信息来调整自身的状态和行为。通过系统主体的相对简单的智能，系统在整体上显示更高层次，更加复杂，更加协调职能的有序性</p>
<h4 id="3-_局部信息，没有中央控制">3. 局部信息，没有中央控制</h4><p>系统中的任意一个个体无法知道系统所有个体的信息（状态和行为），每个个体可以从系统中较小集合中获取信息，处理局部信息，并进行决策。系统的整体行为是通过个体的协作，竞争等局部相互作用</p>
<p>而在<code>汤伟君</code>和<code>邱美虹</code>的这篇论文中介绍了另外几个特性</p>
<h4 id="多层次">多层次</h4><p>例如生物体的组成和运作,可以从器官、组织、细胞、基因等不同层次的面相来讨论</p>
<h4 id="上向因果关系">上向因果关系</h4><p>上向因果关系指的是低层次性质对高层次性质的因果作用(范冬萍,2005)。高层次由低层次组合而产生,他不能脱离低层次事物而独立存在。系统由组件（component）构成，组件由子组件构成，子组件由子子组件构成等等，这就意味着每一个组件可能就是一个独立的系统。</p>
<h4 id="突现,不可预测、不可化约、_非线性">突现,不可预测、不可化约、 非线性</h4><p>突现就是突然出现,不被预期的出现,无法有「先见之明」的预测,引用作者原文中的一段话</p>
<blockquote>
<p>整体论最通俗的表达为:「整体不等于部分之和」、「整体的行为并非个别组成分子所具有」(范冬萍&amp;张华夏,2005)。凡是复杂系统必具备此一特性,也就是「只有在整体(system-as-a-whole)运作的情境下才有意义」的特性(Lesh,2006)。也就是「高层次的事物整体所具有,而其组成成分所不具有,且事先不能由此加以预测的特性。」 例如生命之于生命的物理化学特性,心灵之于神经细胞的生理活动,就是一种突现(谢爱华, 2003)。<br>化约论的观点是,所有的现象都可由其个别组成份子的行为来解释,因此生命可以化约到基因,基因可以化约到DNA,DNA 可用物理化学来解释。<br>非线性指的是两个量之间不成正比关系</p>
</blockquote>
<h4 id="多重因果">多重因果</h4><blockquote>
<p>在一个复杂系统里,层级和成分都很多,因此系统的行为,受到诸多因子的影响,而且主要是受到成分交互作用的影响。随着涉及面的增加,其计算量将以失控方式递增,造成非线性、难以预测的变化(Bosomaier &amp; Green, 1998)。</p>
</blockquote>
<h4 id="成分（系统主体）互动(关系)的重要性大于成分本身">成分（系统主体）互动(关系)的重要性大于成分本身</h4><blockquote>
<p>Waldrop(1992) 指出「生命的本质在于分子的组织和互动,不在于分子」</p>
</blockquote>
<h4 id="动态的,不停止的">动态的,不停止的</h4><blockquote>
<p>又譬如股市的升降,是来自各散客大户各自的互通暗盘消息、阅读金融资讯后,买或卖股票而造成股市市场的波动(上向因果),而市场的降或跌也会影响作用体(股民)们的买卖行为(下向因果)。下向因果的存在,阐明了复杂系统内的交互作用,不仅限于同一阶层内成分的互动,实际上也有跨阶层的互动</p>
</blockquote>
<h4 id="下向因果关系">下向因果关系</h4><blockquote>
<p>这也是复杂系统的重要特性,但并非所有突现现象都有此一特性。所谓下向因果,指的是高层次具有低层次所不具有的性质,并对其组成部分(低层次)有支配作用</p>
</blockquote>
<h4 id="自我组织">自我组织</h4><blockquote>
<p>自组织是部份复杂系统才具有的特性，成分会自动组织成一个体系,如劳力需求、商品、服务自动组织成市场结构, 而这个体系的存在强化了每一成分的连结和存续。</p>
</blockquote>
<p>正如作者所言，自组织起到了自我强化的作用，使得整体的能力强过于个体，而这个自我强化能力之一,便是正回馈</p>
<h4 id="正回馈或报酬递增">正回馈或报酬递增</h4><blockquote>
<p>正回馈的例子在自然界可能造成两大结果,一个是形成自我强化组,例如前面提到的化学反应连锁催化组。另一个效应则是搭配系统内各成分的互动,使得初始状况的小变动,可以导致之后系统的巨大改变,即众所周知的蝴蝶效应(Gleick,1987)。在一个自组织系统里,有可能会受到不起眼的关键分子的影响,而大幅改变了原有的组织型态。例如汽车取代马车之后,所引起的人类经济体系转变,包括行业的兴衰、能源需求、运输能力等都发生了重大改变(Waldrop, 1992)。</p>
</blockquote>
<p>看完了这篇文章的介绍，有几个问题</p>
<ul>
<li>系统主体的智能对复杂系统有何影响？<br>一个复杂系统中的主体如果是人类等有高智能生物，复杂系统会因为个体的不稳定，不确定而变得更加复杂，而相对简单的智能，例如系统主体为晶体管的微处理器，蚂蚁等，则没有那样复杂。所以系统主体的智能水平可以决定一个复杂系统的复杂层次。</li>
<li>为何竞争和协作可以形成更高层次，更加复杂的智能？<br>根据上面的介绍，原因就是「突现（涌现）」，突现使得系统整体具有个体所不具有的特性</li>
<li>复杂系统和非复杂系统（简单系统）的差别？</li>
</ul>
<h3 id="参考文献">参考文献</h3><ol>
<li><a href="http://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%AE%A1" target="_blank" rel="external">晶体管维基百科</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%99%BA%E8%83%BD" target="_blank" rel="external">智能维基百科</a></li>
<li>汤伟君* 邱美虹复杂系统、突现及其对科学教育的启示(2007)</li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/03/06/Performance-Timing/" itemprop="url">
                如何使用Performance-Timing进行性能统计？
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-03-06T00:00:00+08:00" content="2014-03-06">
            2014-03-06
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端开发/" itemprop="url" rel="index">
                  <span itemprop="name">前端开发</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h3 id="几个名词">几个名词</h3><h4 id="window-performance-navigation">window.performance.navigation</h4><p>这个属性存储了2个标记<code>redirectCount</code> （页面跳转的次数）和<code>type</code>（页面访问途径类型），其中<code>type</code>有以下几种取值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TYPE_BACK_FORWARD: <span class="number">2</span></span><br><span class="line">TYPE_NAVIGATE: <span class="number">0</span></span><br><span class="line">TYPE_RELOAD: <span class="number">1</span></span><br><span class="line">TYPE_RESERVED: <span class="number">255</span></span><br></pre></td></tr></table></figure>
<h4 id="window-performance-timing">window.performance.timing</h4><p>包含了页面请求经历的各个时间点，<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming" target="_blank" rel="external">查看MDN上面的文档</a> 例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fetchstart: 浏览器准备发起HTTP请求去拉取文档，这个时刻之后浏览器会去检查是否有缓存</span><br><span class="line">domainLookupStart: DNS Lookup开始，如果用的是持久连接或者访问本地缓存，该时间点等同于fectchStart</span><br><span class="line">domainLookupEnd: DNS Lookup结束</span><br><span class="line">connectStart: 发起TCP链接，如果使用持久连接，该时间点等同于fetchstart</span><br><span class="line">connectEnd: TCP连接结束，如果使用持久连接，该时间点等同于fetchstart</span><br><span class="line">requestStart: 发起请求向服务器获取文档</span><br><span class="line">responseStart: Time to first Byte</span><br><span class="line">responseEnd: 接收完Response或者连接断开</span><br><span class="line">domLoading: 浏览器解析器开始工作Document.readyState 变为loading</span><br><span class="line">domInteractive: 解析完主文档Document.readyState 变为interactive</span><br><span class="line">domContentLoadeded:</span><br><span class="line">domComplete: 浏览器解析完主文档 Document.readyState变为 complete</span><br><span class="line">loadEventStart: 浏览器触发load事件</span><br><span class="line">loadEventEnd: load事件的处理函数执行结束</span><br></pre></td></tr></table></figure>
<h3 id="用法举例">用法举例</h3><h4 id="DNS_Lookup时间">DNS Lookup时间</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dns = perfData.domainLookupEnd - perfData.domainLookupStart;</span><br></pre></td></tr></table></figure>
<h4 id="Tcp">Tcp</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tcp = perfData.connectEnd - perfData.connectStart</span><br></pre></td></tr></table></figure>
<h4 id="页面加载总时间">页面加载总时间</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> perfData = <span class="built_in">window</span>.performance.timing;</span><br><span class="line"><span class="keyword">var</span> pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;</span><br></pre></td></tr></table></figure>
<h4 id="数据传输时间">数据传输时间</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅仅是数据下载的时间</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> requestTime</span> = perfData.responseEnd - perfData.requestStart;</span><br></pre></td></tr></table></figure>
<h4 id="网络传输时间：包括Redirect，DNS_Lookup，建立连接">网络传输时间：包括Redirect，DNS Lookup，建立连接</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> requestTime = perfData<span class="class">.responseStart</span> - perfData.navigationStart</span><br></pre></td></tr></table></figure>
<h4 id="首字节时间_Time_To_First_Byte">首字节时间 Time To First Byte</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> ttfb</span> = perfData.responseStart - perfData.navigationStart;</span><br></pre></td></tr></table></figure>
<h4 id="可交互时间TTI">可交互时间TTI</h4><p>TTI(Time To Interact)指的是页面可交互的时间。页面中的交互包括很多方面，例如点击一个链接、点击一个搜索按钮都属于页面交互的范畴，但是对于衡量性能的TTI则主要指核心功能可以交互的时间。核心功能的定义则是随着页面的不同而不同，例如对于百度首页而言，最为关键的就是搜索框出现的时间、而对于一些购物网站的商品详情页最关键的是购买功能可用和描述出现的时间。而目前的实际情况，TTI大都等于DOM Ready时间，因为不论交互功能是否重要，相关的Javascript都会在DOM Ready后才进行初始化和绑定，而实际上TTI是可以更早的。</p>
<p>如果界面交互不依赖于javascript,例如纯html页面，可交互时间等于</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> tti</span> = perfData.domInteractive - perfData.navigationStart;</span><br></pre></td></tr></table></figure>
<p>如果界面交互依赖于javascript，可交互时间则没有一个很好的基准，因为不同的应用对可交互的定义并不一样</p>
<p>如果要求不严格，近似的估计可以是</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> tti</span> = perfData.domComplete - perfData.navigationStart;</span><br><span class="line">或者</span><br><span class="line"><span class="variable"><span class="keyword">var</span> tti</span> = perfData.domContentLoaded - perfData.navigationStart;</span><br></pre></td></tr></table></figure>
<p>更细节的可以是根据业务的场景来判断用户界面什么时候可以交互; 例如一个富文本编辑器的可交互时间，取决于主js文件什么时候完成编辑器的初始化；</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> tti</span> = 编辑器完成初始化的时间点 - perfData.navigationStart;</span><br></pre></td></tr></table></figure>
<h4 id="页面完全加载">页面完全加载</h4><p>为什么用 loadEventEnd这个时间点表示页面加载完成呢？</p>
<blockquote>
<p>The DOMContentLoaded event is fired when all of the page’s DOM content has been loaded and parsed. The load event is fired once all of the document’s resources (images and CSS files, and so forth) have been fully loaded.</p>
</blockquote>
<p><code>DOMContentLoaded</code>代表的是DOM解析完成并加载，而 <code>load</code> 事件 是页面引用的所有资源文件都加载完成. 所以 load 一般是最后才触发的.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">perfData</span><span class="class">.loadEventEnd</span> <span class="tag">-</span> <span class="tag">perfData</span><span class="class">.navigationStart</span>;</span><br></pre></td></tr></table></figure>
<h3 id="如何测试Ajax请求的时间呢？">如何测试Ajax请求的时间呢？</h3><p>由于<code>performerce.timing</code>不能用于ajax请求，而是通过<code>mark</code> 和 <code>measure</code>的方式来求得的，用到了两个接口</p>
<ul>
<li><code>performance.mark</code></li>
<li><code>performance.measure</code></li>
<li><code>performance.getEntriesByType</code></li>
</ul>
<p>如下例所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记请求的开始</span></span><br><span class="line"><span class="built_in">window</span>.performance.mark(<span class="string">'mark_start_xhr'</span>);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="keyword">this</span>.url.newReport,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//标记请求结束</span></span><br><span class="line">        <span class="built_in">window</span>.performance.mark(<span class="string">'mark_end_xhr'</span>);</span><br><span class="line">        <span class="comment">//求值</span></span><br><span class="line">        <span class="built_in">window</span>.performance.measure(<span class="string">'measure_xhr'</span>, <span class="string">'mark_start_xhr'</span>, <span class="string">'mark_end_xhr'</span>);</span><br><span class="line">        <span class="keyword">var</span> items = <span class="built_in">window</span>.performance.getEntriesByType(<span class="string">'measure'</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(items);</span><br><span class="line">        doSomething(resp)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考：">参考：</h3><ol>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming" target="_blank" rel="external">Performace timing Api</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webperformance/basics/" target="_blank" rel="external">Measuring Page Load Speed​​​​ with Navigation Timing</a></li>
<li><a href="http://www.w3.org/TR/navigation-timing/" target="_blank" rel="external">w3c navigation timing</a></li>
<li><a href="http://www.w3.org/TR/html5/syntax.html#the-end" target="_blank" rel="external">DOMContentLoaded Event From W3c</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events/DOMContentLoaded" target="_blank" rel="external">DomContentLoaded EventFrom MDN</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/webperformance/usertiming/" target="_blank" rel="external">http://www.html5rocks.com/en/tutorials/webperformance/usertiming/</a></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/02/12/有關響應時間的問題/" itemprop="url">
                响应时间应该多长才算快？
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-02-12T00:00:00+08:00" content="2014-02-12">
            2014-02-12
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端开发/" itemprop="url" rel="index">
                  <span itemprop="name">前端开发</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>最近被一個問題困擾許久，在移動端中，Response Times究竟在什麼樣的範圍是用戶可以接受的？網上有一篇文章<a href="http://www.nngroup.com/articles/response-times-3-important-limits/" target="_blank" rel="external">Response Times: The 3 important Limits</a>被許多性能優化的文章引用.文中指出了這樣的幾個數據:</p>
<ul>
<li>0.1s 馬上響應，也就意味著不需要任何反饋。用戶認為系統的輸出是由自己造成的，而不是計算機。感覺像是直接是在直接操作界面上的東​​西(direct manipulation 是提高用戶參與度和控制力的關鍵技術，更多請參考：<a href="http://www.nngroup.com/courses/hci/" target="_blank" rel="external">User Interface Principles Every Designer Must Know, Applying human-computer interaction (HCI) lessons to inform and defend UX decisions</a>)。例如：有一個表格，用戶可以點擊表頭進行排序，如果用戶點擊表頭之後能夠在0.1s完成排序，用戶覺得是自己在操作表格，否則，用戶則感覺是自己通知計算機去排序。</li>
<li>1.0s 用戶可以察覺到延遲, 但是還不至於打斷用戶的思緒（flow of thought）。 0.2s~1s的處理時間讓用戶察覺到了延遲，並且意識到計算機在工作，而不是立馬響應用戶的操作。例如：如果表格排序需要1s才能夠完成，用戶可以感覺到體驗沒那麼流暢，會有卡頓的感覺。而如果超過1s，則需要給用戶處理中的反饋了，否則“卡頓”就變成為“卡死”了，</li>
<li>10s 超過這個時間點，用戶就會失去耐心和關注度； 超過10s時用戶會想要離開當前任務而等待計算機完成之後再回來，所以需要處理進度（處理中，已完成等）的提示。如果缺少進度提示，則用戶無從知道當前的任務的狀態，就容易給用戶留下任務卡死的感覺。任何超過10s的任務都必須要有進度提示，並且可以讓用戶取消該任務。</li>
</ul>
<p>響應時間自然是越快越好，如果無法達到理想的響應速度(100ms)，進度提示（進度條，菊花轉等）就是必須的了,進度提示的好處是：</p>
<ul>
<li>讓用戶知道系統沒有出錯，還在為她/他處理問題中。</li>
<li>如果是完成進度提示的（例如進度條），用戶就可以知道還剩下多少</li>
<li>給用戶一些視覺反饋，讓等待的過程沒有那麼痛苦，好歹有些可以看的。</li>
</ul>
<p>為什麼速度那麼重要？在這篇文章中<a href="http://www.nngroup.com/articles/website-response-times/" target="_blank" rel="external">website response times</a>中提到了兩點：</p>
<p>Human Limitations(人類本身的限制): 人類的短期記憶和注意力無法長時間集中<br>Human aspirations(人性渴望): 渴望控制自己的命運，而不是屈服於計算機，例外，如果一個公司提供的服務響應速度過慢，給人的留下的印像是傲慢和無能（請腦補國內幾個國有企業的系統或網站）。</p>
<p>文中還提到了另外一點就是在一個“過往經驗對品牌的影響(Brand as Experience)”的調查中，用戶對一個網站的印像中，響應速度是很重要的一項，所以快速的響應速度對一個網站的“名聲”是相當重要的</p>
<p>100ms的微小提升都會對網站的<a href="http://www.nngroup.com/articles/conversion-rates/" target="_blank" rel="external">轉換率(Conversion Rates)</a>有一定的提升</p>
<p>###參考</p>
<ol>
<li><a href="http://www.nngroup.com/articles/response-times-3-important-limits/" target="_blank" rel="external">Response Times: The 3 Important Limits</a></li>
<li><a href="http://www.nngroup.com/articles/powers-of-10-time-scales-in-ux/" target="_blank" rel="external">Powers of 10: Time Scales in User Experience</a></li>
<li><a href="http://www.nngroup.com/articles/website-response-times/" target="_blank" rel="external">Website Response Times by JAKOB NIELSEN on June 21, 2010</a></li>
<li><a href="http://www.nngroup.com/courses/fundamentals/" target="_blank" rel="external">Top Web UX Design Guidelines</a></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/02/10/如何测试后端API性能？/" itemprop="url">
                如何测试后端API的性能?
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-02-10T00:00:00+08:00" content="2014-02-10">
            2014-02-10
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端开发/" itemprop="url" rel="index">
                  <span itemprop="name">前端开发</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>目前流行的Web APP，数据一般都是异步加载的，后端提供API给前端，假如这个APP的HTML，JS，CSS，Image等静态资源都已经进行了足够的优化，那么剩下会影响加载速度的就是后端API了，后端API加载时间长，用户可交互的时间点就会越靠后。</p>
<p>那么什么样的API才算是性能良好的API呢？</p>
<p>站在用户的角度，等待的时间必定是越短越好，在PC端 200-1000ms内数据就返回，对于用户来讲是一个比较好的用户体验，但是对于移动端网络来讲，用户如果处于2G/3G网络，这个时间有点过于苛刻。</p>
<p>那么，移动端的性能要求怎样才算是合理呢？这个可能需要一个用户调研，但是目前暂时没有资源做这一块。所以，暂时只能做好所有的优化，将一些可能存在的优化点进行解决。然后再进行多一次测试，对比优化前和优化后的数据，差距多大。</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">加载总时间 </span>=<span class="string"> DNS解析 + 连接时间 + 首字节返回时间 + 下载时间</span></span><br></pre></td></tr></table></figure>
<p><code>首字节时间</code>(发起连接到服务器返回首字节的时间)<code>T1 = 网络来回传输时间 +  服务器处理时间</code>；所以其相关因素有：网络传输速度，服务器性能</p>
<p>而<strong><code>下载时间</code></strong>的相关因素：网络传输速度，返回内容大小；</p>
<p>所以从加载总时间可以看出：返回内容大小，服务器性能，DNS解析时间。这个是可以优化的点。</p>
<p>优化有那么方面可以着手呢？</p>
<ul>
<li>如果全集群部署依旧出现解析时间较长的，就需要使用CDN了</li>
<li>服务器性能</li>
<li>检查API返回结果是否进行压缩，如果已经有压缩，是否还有优化方法能够减少返回结果的大小</li>
</ul>
<h3 id="参考">参考</h3><p><a href="http://www.oschina.net/translate/testing-the-api-backend-of-your-mobile-solution" target="_blank" rel="external">http://www.oschina.net/translate/testing-the-api-backend-of-your-mobile-solution</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/01/20/CSS-Architecture/" itemprop="url">
                CSS Architecture
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-01-20T00:00:00+08:00" content="2014-01-20">
            2014-01-20
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/前端开发/" itemprop="url" rel="index">
                  <span itemprop="name">前端开发</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>这篇文章部分翻译自：<a href="http://engineering.appfolio.com/2012/11/16/css-architecture/" target="_blank" rel="external">CSS Architecture</a> ，包括个人的一些见解和对例子的补充。</p>
<blockquote>
<p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification. </p>
</blockquote>
<p>###作者提到优雅的CSS代码应该有的特点</p>
<ul>
<li><p><strong>可预测(predictable)</strong> 可预测意思是，CSS规则按照你预期的效果。单你更新一个CSS规则的时候，不会影响到你不想改变的模块，特别是大型站点动则几百个CSS文件，可预测就显得更加重要</p>
</li>
<li><p><strong>可重用(reusable)</strong> 抽象和解耦的好的CSS规则的好处是，当你创建新的组件时，可以复用已有的CSS规则，而不需要重新写一个新的CSS规则</p>
</li>
<li><p><strong>可维护(maintainable)</strong> 添加新组件或者新特性的时候，不会需要修改已有的CSS规则。如果添加一个新CSS规则，就会破坏其他模块的样式，这明显不是一份可维护的CSS代码</p>
</li>
<li><p><strong>可伸缩(scalable)</strong> 随着网站变大和复杂度变高，往往需要更多的人来维护，可伸缩意味着不管你是单人开发，还是团队开发，都可以管理好CSS规则，不会变成一盘意大利面。可伸缩还意味着学习曲线的平坦，新的开发人员可以尽快的掌握目前的代码。</p>
</li>
</ul>
<h3 id="常見的幾種CSS寫法">常見的幾種CSS寫法</h3><p>有一個基礎的parent，然后使用到的組件再去擴展。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.widget</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> yellow</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"> <span class="number">1px</span> solid black</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value"> black</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">50%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="id">#sidebar</span> <span class="class">.widget</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">200px</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">body</span><span class="class">.homepage</span> <span class="class">.widget</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>這樣的寫法剛開始看起來應該是無害的，但是我們來根據上面的幾個特性來分析：</p>
<p>首先不容易重用(reusable)和伸縮(scalable)，如果還有其他頁面要使用widget，那就要添加新的CSS規則來達到目的，例如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span><span class="class">.pageA</span> <span class="class">.widget</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> white</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">body</span><span class="class">.pageB</span> <span class="class">.widget</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background</span>:<span class="value"> green</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>其次，這個代碼很難維護（maintainable），因為如果要重新設計widget的時候，所有相關的地方都有可能要修改，而且這些修改的地方不會像上面一樣聚在一起那麼好找。</p>
<h4 id="過度複雜的CSS選擇器">過度複雜的CSS選擇器</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#main-nav</span> <span class="tag">ul</span> <span class="tag">li</span> <span class="tag">ul</span> <span class="tag">li</span> <span class="tag">div</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"><span class="id">#content</span> <span class="tag">article</span> <span class="tag">h1</span><span class="pseudo">:first-child</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"><span class="id">#sidebar</span> &gt; <span class="tag">div</span> &gt; <span class="tag">h3</span> + <span class="tag">p</span> <span class="rules">&#123; &#125;</span></span><br></pre></td></tr></table></figure>
<p>越複雜的選擇器代表你的CSS規則和HTML耦合得更深, 像上面的CSS規則相對應的HTML代碼一旦改變，CSS規則也得隨著要修改了。 雖然這種複雜的選擇器會讓你的HTML很簡潔，但是會讓你的CSS變得很複雜而且會有性能問題。</p>
<ul>
<li><strong>無法重用</strong>，一個HTML結構不同的組件就用不了這個CSS規則了</li>
<li>無法預測，如果 <code>#sidebar &gt; div &gt; h3 + p { }</code> 規則對應的HTML結構中的<code>div</code> 改為 <code>section</code> ，那麼這條規則就無效了</li>
<li>難維護，顯而易見</li>
<li>無法伸縮</li>
</ul>
<p>在CSS和HTML這兩者的複雜度之間做權衡，而為了HTML的簡潔，不使用ID和CLASS，這樣的確可以讓HTML看起來簡潔，但是CSS卻會是非常複雜，這種為了HTML的簡潔性而付出的代價是得不償失的。對於個人而言，我偏向于將複雜度轉移到HTML，儘可能保持CSS的簡潔。</p>
<h3 id="CSS类名起得太大路货">CSS类名起得太大路货</h3><p>HTML</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"widget"</span>&gt;</span><br><span class="line">  &lt;h3 <span class="type">class</span>=<span class="string">"title"</span>&gt;...&lt;/h3&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"contents"</span>&gt;</span><br><span class="line">    Lorem ipsum dolor sit amet, consectetur adipiscing elit.</span><br><span class="line">    In condimentum justo et est dapibus sit amet euismod ligula ornare.</span><br><span class="line">    Vivamus elementum accumsan dignissim.</span><br><span class="line">    &lt;button <span class="type">class</span>=<span class="string">"action"</span>&gt;Click Me!&lt;/button&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>CSS</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.widget</span> <span class="rules">&#123;&#125;</span></span><br><span class="line"><span class="class">.widget</span> <span class="class">.title</span> <span class="rules">&#123;&#125;</span></span><br><span class="line"><span class="class">.widget</span> <span class="class">.contents</span> <span class="rules">&#123;&#125;</span></span><br><span class="line"><span class="class">.widget</span> <span class="class">.action</span> <span class="rules">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>這個CSS規則本意是為了避免 .title .contents .action只在.widget下面生效，而不影響其他模塊，但是這種太過“大路貨”的名字很容易被其他模塊破壞， 例如 下面這個規則就會破壊 .widget .title {} 這個規則</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.title</span> <span class="rules">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>同時也有可能破壞其他模塊，例如上面的CSS規則就會破壞下面的CSS規則</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.sidebar</span> <span class="rules">&#123;&#125;</span></span><br><span class="line"><span class="class">.sidebar</span> <span class="class">.widget</span> <span class="class">.title</span> <span class="rules">&#123;&#125;</span></span><br><span class="line"><span class="class">.sidebar</span> <span class="class">.widget</span> <span class="class">.contents</span> <span class="rules">&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3><p>上面幾個bad practice都有一個類似的地方，就是將太多的责任負擔在了CSS之上。</p>
<p>CSS不就是為了樣式而存在的嗎？把樣式的任務交給CSS應該是很自然的吧? CSS的確是為了樣式而存在，但是把HTML和樣式簡單的分離開來並不是真正的分離，如果像 “過度複雜的CSS選擇器” 中的例子，CSS還需要了解HTML結構，反而没有达到解耦的目的了。</p>
<p>現階段HTML並不僅僅是內容，HTML也包含了結構。所以HTML和CSS一起合作作為展示層（Presentation Layer）是一個比較明智的做法。模板描述數據的展示形式，接着使用模板渲染渲染数据，最后构成显示层</p>
<h3 id="如何解决上述问题">如何解决上述问题</h3><p>CSS尽可能少的和HTML结构耦合在一起,<br>缩小CSS定义的粒度，粒度越细，可复用性就越高<br>CSS规则不管应用在页面的那个位置，保证它们的表现都是相同的</p>
<p>例如，一般情况下我们会这么去定义一个按钮</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.button</span><span class="rules">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.sidebar</span> <span class="class">.button</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样子其实是和HTML结构耦合在一起的，因为需要类似于这样子的结构才可以使用上面的CSS规则</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"sidebar"</span>&gt;</span><br><span class="line">    &lt;button <span class="type">class</span>=<span class="string">"button"</span>&gt;&lt;/button&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>那么应该怎么改进呢？看下面的代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.button</span><span class="rules">&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.full-width</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">width</span>:<span class="value"> <span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>缩小每一条CSS规则的粒度，然后将样式的组合交给HTML来控制,这样子CSS就不会和HTML结构耦合在一起,同时开发者看了class中用到的类名，就能够知道这个元素看起来会是什么样子，一目了然，就算是多人开发也不会有疑惑。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">button</span> class=“<span class="tag">button</span> full-<span class="attribute">width</span>”&gt;&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出 .full-width 这个类，不管用在页面上的任意位置，它所起的作用都是一样的，而且由于粒度较细，很容易给其他组件复用，。例如现在有一个article需要full-width，同样只需要在class增加这个.full-width类即可，其他开发人员一看就知道这是个full-width这个类名，就知道这是一个满宽度的Article。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">article</span> <span class="attribute">class</span>=<span class="value">“other-class-name</span> <span class="attribute">full-width</span>”&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- content --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">article</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>看到这里你也许会有个疑问，这样子元素的class就有可能很复杂了，例如:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--一个大边框，背景为灰色，float right, 文字居中对齐的div--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"thick_border bg_gray fl_right al_center"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而且如果网页需要100个这样子的DIV，那服务器端就需要渲染100个这样子的div，那岂不是多了很多文本，让网页变大了？</p>
<p>是的，的确会这样子。但是由于有GZIP，根据GZIP的压缩原理，其实这种造成的影响不会特别大。况且，不要忘了，我们还有前端模板引擎。我们将这100个div的渲染任务交给前端来渲染。而从服务器加载的网页中只需保存有这个div的模板即可。</p>
<h3 id="CSS_Best_Practice">CSS Best Practice</h3><h4 id="1-_分离关注点_SoC">1. 分离关注点 SoC</h4><p>平时用编程语言，例如c++，java，javascript编写程序时，SoC是一个很重要的原则，那么在CSS中也是同理。 在写CSS过程中，很多人都会遇到CSS难维护的问题，但是问题并不是出在CSS本身，而是我们使用的方式不对（具体看上面介绍的各种Bad Practice）。一个好的CSS模块有什么特性呢</p>
<blockquote>
<p>当其中一个模块发生改变时，不会影响到其他模块。</p>
</blockquote>
<p>这样有助于降低开发复杂度，提高可维护性。</p>
<p>那么具体应该怎么做呢？</p>
<p>例如：一般来说，定义一个CSS模块的时候，我们关注的是它的外观,而不是他们的位置和布局 (define how they look, but not their layout or position) . 当一个css模块的定义中出现诸如：background、font-size 和 position、 width、height、margin 这些混合在一起的时候，就要注意一下了, 可以试着把一个各种属性混合的类拆分为开来，分成布局类(position, width…)和外观类(background, font-size…)。 或者，也可以增加一个容器来负责布局。例如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"category"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>大数据<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">li</span>&gt;</span>前端开发<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>它的CSS是：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.category</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"> <span class="hexcolor">#CCC</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">1.5rem</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"> <span class="hexcolor">#EEE</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">list-style</span>:<span class="value">none</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value"> fixed</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>从category这个CSS模块可以看到， 布局（margin、position）和外观（color、font-size）是混合在一起的. 是时候把它们分离开来了，</p>
<ul>
<li>方法1：我们可以拆分成两个类</li>
<li>方法2：增加一个容器</li>
</ul>
<p>方法1比较容易理解，这里就不举例子了。这里介绍一下方法2：</p>
<p>首先改造一下CSS结构</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 增加多一个容器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"fixed M-10"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"category"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>大数据<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">li</span>&gt;</span>前端开发<span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后再改造一下CSS</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.category</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#CCC</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">font-size</span>:<span class="value"><span class="number">1.5rem</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#EEE</span></span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">list-style</span>:<span class="value">none</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.fixed</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">position</span>:<span class="value">fixed</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.M-10</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">margin</span>:<span class="value"> <span class="number">10px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>改造之后，打碎了原有的CSS模块，现在分成了一个外观类 .category 和 两个布局类 <code>.fixed</code> <code>.M-10</code> , 与之前相比，由什么改变呢？<br>模块的粒度变小了，而且这些细粒度的模块都是可复用的<br>解开了外观和布局之间的耦合，现在category这个CSS模块可以用在页面的任意位置<br>如何检查关注点分离得好不好呢？换句话说：模块分离得清不清晰呢？这里有个经验：假设这个CSS模块未来会用在很多地方，能否做到让这个模块的代码不做任何修改就直接可用呢。</p>
<h4 id="2-_命名空间_NameSpace">2. 命名空间 NameSpace</h4><p>在前面的Bad Practice介绍过：我们知道了CSS类名起得太大路货的各种坏处，父亲选择器无法100%的做到封装和阻止样式污染。而更好的解决办法就是使用命名空间。如果一个元素属于某一个可视组件，那么这个元素就应该使用该组件的类名作为自己的前缀。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 容易造成样式的交叉污染 */</span></span><br><span class="line"><span class="class">.widget</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"><span class="class">.widget</span> <span class="class">.title</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 有效阻止样式的交叉污染 */</span></span><br><span class="line"><span class="class">.widget</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"><span class="class">.widget-title</span> <span class="rules">&#123; &#125;</span></span><br></pre></td></tr></table></figure>
<p>命名空间保持了模块的自包含（self-contained），降低了样式定义出现交叉污染的可能性。</p>
<h4 id="3-_创建一个新的CSS类来扩展模块">3. 创建一个新的CSS类来扩展模块</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不好 */</span></span><br><span class="line"><span class="class">.widget</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"><span class="id">#sidebar</span> <span class="class">.widget</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 好 */</span></span><br><span class="line"><span class="class">.widget</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"><span class="class">.widget-sidebar</span> <span class="rules">&#123; &#125;</span></span><br></pre></td></tr></table></figure>
<p>为什么说第一种不好呢？</p>
<p>因为CSS和HTML结构耦合在一起了，这个扩展之后的CSS模块只能在特定的位置使用，例如本例中的#sidebar .widget，是无法在页面的其他HTML结构下复用这个CSS模块的。而第二种写法则可以在页面的任意位置复用。</p>
<p>另外，观察例子中的两种写法，可以发现单独从class的名字 .widget-sidebar 就可以看出开发者的意图（这个widget是 widget-sidebar，与其他widget不一样）. 而在不好的方案中，如果你仅仅看HTML代码，你能够立马看出这个widget是和页面的其他widget是不同的吗？</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"sidebar"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"widget"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>仅仅从HTML你是无法知道这是一个扩展过的widget，你要等到看到这条CSS规则 <code>#sidebar .widget { }</code>才后知后觉： “檫，怪不得这个widget看起来就不是不一样”。所以创建一个新的CSS类来扩展模块的有助于HTML和CSS的解耦。</p>
<h4 id="4-_组织好CSS的逻辑结构">4. 组织好CSS的逻辑结构</h4><p>Jonathan Snook在他的书 SMACSS 中提出一种组织CSS规则的方式：</p>
<p>将CSS规则归类成 <code>Base</code>, <code>Layout</code>,<code>Modules</code>, <code>State</code> 4个类别</p>
<ul>
<li>Base: reset规则和一些默认样式</li>
<li>Layout: 站点通用的布局，表格系统等</li>
<li>Modules：可重用的视觉元素，这个类别包含了大部分的CSS规则</li>
<li>State: 一些javascript使用到的状态标记位</li>
</ul>
<p>在CSS设计中，每一个视觉元素都是独立的，而这些视觉元素则是由若干个CSS规则构成的，这些规则就像是房子的砖块。不过我们在这里学术的称之为 Template，单独一个Template很少可以独立描述一个完整的视觉元素，我们通过组合多个Template来构成一个完整的视觉元素。这里比较抽象，举一个常见的例子：弹出框 Modal</p>
<p>对话框有一个与站点风格统一的渐变的Header，在右上角有一个关闭按钮，可能是<code>position fixed</code>，也可能是垂直水平居中，而这些规则在站点中可能被一次次的复用，你不会想每一次都重新编写一次。所以这些规则就是Template，它们组合在一起构成了一个弹出框。</p>
<h4 id="5-_class仅用来定义样式">5. class仅用来定义样式</h4><p>做过一些稍大型的项目的人都会经历过这样的事情：在一个html元素的class中找到“存在原因不明”的类名，你很想删之而后快，但你又害怕引起错误，因为这个“黑户” 很可能是在javascript文件中使用的一个选择器。这种事情一次次发生之后，你会发现你的HTML文件布满了这种对样式定义无意义的class。</p>
<p>这种情况的发生是因为在前端开发中，class承担了太多的职责，定义html元素的样式，javascript中的选择器，用来做功能检测的标记位（<code>.on</code> <code>.disabled</code> <code>.checked</code> 看起来熟悉吗？）。承担的职责多了，就容易牵一发动全身。</p>
<p>Philip Walton 介绍了一种方法：类名前缀，例如</p>
<ul>
<li>javascript中的选择器  ‘.js-’ ， 例如：.js-this-is-a-selector</li>
<li>功能检测   ‘.fd-‘ ( feature-detection的缩写) ， 例如：.fd-on</li>
</ul>
<p>使用了前缀之后也就要求，样式class的名称不能以 .js- 和 .fd- 开头，没有使用前缀的类名就只能用来定义样式，不能有其他职责。这样子要移除无用的CSS样式定义就容易许多了，只要不带前缀便可以安全移除。</p>
<h4 id="6-_使用有逻辑结构的类名">6. 使用有逻辑结构的类名</h4><p>Philip Walton 文中采用了 Nicolas Gallagher 的一个解决办法 About HTML semantics and front-end architecture</p>
<p>我们来看看下面的CSS代码，观察这段代码有什么问题</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个模块 */</span></span><br><span class="line"><span class="class">.button</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改一个模块 (修改.button类) */</span></span><br><span class="line"><span class="class">.button-primary</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子类 (什么！这是button一个子类？为什么上面的写法是修改一个模块呢？) */</span></span><br><span class="line"><span class="class">.button-icon</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个模块类名，还是一个布局的类名？ */</span></span><br><span class="line"><span class="class">.header</span> <span class="rules">&#123; &#125;</span></span><br></pre></td></tr></table></figure>
<p>问题就是：根本不可能从类名上看出这个类的类型（模块，布局？），这样让开发过程中容易出现困惑。类名的命名规范使得你可以只看类名就知道这个类和其他类的关系，以及HTML中那些地方可以用到它。</p>
<p>Philip Walton的解决方案：通过分隔符和前缀的方式来区分各种CSS规则</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Component Rules */</span></span><br><span class="line"><span class="class">.component-name</span></span><br><span class="line"><span class="class">.component-name--modifier-name</span></span><br><span class="line"><span class="class">.component-name__sub-object</span></span><br><span class="line"><span class="class">.component-name__sub-object--modifier-name</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Layout Rules */</span></span><br><span class="line"><span class="class">.l-layout-method</span></span><br><span class="line"><span class="class">.grid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* State Rules */</span></span><br><span class="line"><span class="class">.is-state-type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-styled JavaScript Hooks */</span></span><br><span class="line"><span class="class">.js-action-name</span></span><br><span class="line">按照这个方案，可以改写上面的例子</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一个模块 */</span></span><br><span class="line"><span class="class">.button</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改.button类 */</span></span><br><span class="line"><span class="class">.button--primary</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 子类  */</span></span><br><span class="line"><span class="class">.button__icon</span> <span class="rules">&#123; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 布局类 */</span></span><br><span class="line"><span class="class">.l-header</span> <span class="rules">&#123; &#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="7-_工具">7. 工具</h4><p>待补充…</p>
<h2 id="总结-1">总结</h2><p>css不会只是视觉设计，不要抛弃编程中的各种最佳实践，OOP ,DRY ,open/close,SoC对于CSS是同样有效的</p>
<p>CSS的各种最佳实践的愿景：</p>
<ul>
<li>快速开发，长期迭代</li>
<li>团队可伸缩</li>
<li>平坦的学习曲线，项目组只要增加开发人员就可提高开发速度，而不是降低。</li>
<li>代码的重用</li>
<li>代码的可重用可以保持UI的一致性，缩减界面开发时间。</li>
</ul>
<p>感兴趣的同学，推荐阅读一下下面几个解决方案：</p>
<ul>
<li>BEM <a href="http://bem.info/method/definitions/" target="_blank" rel="external">http://bem.info/method/definitions/</a></li>
<li>SMACSS <a href="http://smacss.com/" target="_blank" rel="external">http://smacss.com/</a></li>
</ul>
<h2 id="参考">参考</h2><ul>
<li>CSS Architecture </li>
<li>About HTML semantics and front-end architecture </li>
<li>Jonathan Snook  SMACSS </li>
<li>A New Front-End Methodology: BEM</li>
<li>30 CSS Best Practices for Beginners</li>
</ul>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2014/01/01/vim使用笔记/" itemprop="url">
                Vim使用技巧集合
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-01-01T00:00:00+08:00" content="2014-01-01">
            2014-01-01
          </time>
        </span>

        
          <span class="post-category" >
            &nbsp; | &nbsp; 分类于
            
              <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                <a href="/categories/工具/" itemprop="url" rel="index">
                  <span itemprop="name">工具</span>
                </a>
              </span>

              
              

            
          </span>
        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>记录下vim使用过程的技巧，方便以后查询</p>
<p>#Vim学习笔记</p>
<h2 id="技巧">技巧</h2><h3 id="字符操作">字符操作</h3><h4 id="基础">基础</h4><ul>
<li>i  进入Insert模式</li>
<li>o  进入Insert模式并换行</li>
<li>s  允许使用多个字符替换一个单个的字符（以插入方式替换）。</li>
<li>r  replace 替换</li>
<li>R  替换多个字符（以覆盖方式替换）</li>
<li>a  append 追加</li>
<li>p  黏贴于光标后</li>
<li>P  黏贴于光标前</li>
<li>C  允许替换从当前光标位置到本行末尾的所有字符。</li>
<li>visual 模式下面的字符串选择</li>
</ul>
<h4 id="进阶">进阶</h4><ul>
<li><code>]p</code> 自動indent的黏貼</li>
<li><code>:n1,n2 m n3</code>     移动n1-n2行(包括n1,n2)到n3行之下；</li>
<li><code>:n1,n2 co n3</code>    复制n1-n2行(包括n1,n2)到n3行之下；</li>
<li><code>:n1,n2 d</code>        删除n1-n2行(包括n1,n2)行</li>
</ul>
<h3 id="光标移动">光标移动</h3><h4 id="基础-1">基础</h4><ul>
<li>gg 首行</li>
<li>G  尾行</li>
<li>80% 文件80%处</li>
<li>^ 行首</li>
<li>$ 行尾</li>
<li>gi 回到最后一次编辑的位置</li>
<li>% 在括号的头尾来回切换</li>
<li>e 单词尾部</li>
<li>w 下一个单词</li>
<li>b 上一个单词</li>
<li>fx/Fx 向前/向后 移动到任意字符x处</li>
<li>nG 跳到第n行</li>
<li><code>Ctrl-f</code>  前进一页</li>
<li><code>Ctrl-b</code>  后退一页</li>
<li><code>*</code> 移動到下一個與當前單詞一樣的單詞</li>
<li><code>#</code> 移動到下一個與當前單詞一樣的單詞</li>
</ul>
<h4 id="进阶-1">进阶</h4><ul>
<li>H 跳到窗口顶部</li>
<li>M 跳到窗口中央</li>
<li>L 跳到窗口底部</li>
<li>zz - move current line to the middle of the screen</li>
<li>zt - move current line to the top of the screen</li>
<li>zb - move current line to the bottom of the screen</li>
<li>ma 标记当前行</li>
<li>‘a 跳到标记a的行</li>
<li>‘’ (两个单引号)  回到上一次跳转位置</li>
<li>visual 模式下  &lt; &gt; 是缩进的控制</li>
<li>大小写改变<ul>
<li>~ 单个字符大小写切换</li>
<li>g~ (大小写切换) ，gu (变小写), gU (变大写)  通过movement（即上下左右）来控制 例如：g~上, 可以把当前行和上一行变为大(小)写</li>
<li>gUU(当前行变大写) g~~(当前行大小写切换) guu （当前行变小写）</li>
<li>可以跟上w, b,$, ^等来自由发挥， 例如  gu3w  将前面3个单词变小写  同理的还有 gu3b  gU3w  g~$   g~^等等</li>
</ul>
</li>
</ul>
<h3 id="文件操作">文件操作</h3><h4 id="基础-2">基础</h4><ul>
<li>vim -o file….  水平分割打开几个文件</li>
<li>vim -O file…  垂直分割打开几个文件</li>
<li><code>:new filename</code> 在新窗口打开查看文件</li>
<li><code>:vert new filename</code> 水平分割打开新窗口</li>
<li><code>:tab new</code> 在新tab创建文件</li>
</ul>
<h3 id="buffer的操作">buffer的操作</h3><p>####基础</p>
<ul>
<li><code>:ls</code> 或者 <code>:buffers</code> 查看buffer列表</li>
<li><code>:vert sb N</code>   在垂直窗口打开列表</li>
<li><code>:bfirst</code> 去到第一个buffer</li>
<li><code>:bn</code>  next buffer</li>
<li><code>:bp</code>  prev buffer</li>
<li><code>:e &lt;filename&gt;</code> will just open into a new buffer. </li>
</ul>
<h2 id="窗口管理"><a href="http://vimdoc.sourceforge.net/htmldoc/windows.html" target="_blank" rel="external">窗口管理</a></h2><p>概念：</p>
<ul>
<li>A buffer is the in-memory text of a file.</li>
<li>A window is a viewport on a buffer.</li>
<li>A tab page is a collection of windows.</li>
</ul>
<h3 id="window">window</h3><h4 id="基础-3">基础</h4><ul>
<li><code>Ctrl-W n</code> 创建一个水平新窗口，新建文件  等同于 <code>:new</code>   而<code>:vne</code>则是建立一个垂直分割的窗口</li>
<li><code>Ctrl-W s</code> 创建水平分割窗口，编辑当前Buffer   <code>:sp</code></li>
<li><code>Ctrl-W v</code>  创建垂直分割窗口，编辑当前Buffer</li>
<li><code>Ctrl-W q</code>  关闭一个分割窗口</li>
<li><code>Ctrl-W r</code>  向右移动窗口</li>
<li><code>Ctrl-W T</code>  移动窗口到新Tab</li>
<li><code>Ctrl-W</code></li>
</ul>
<h4 id="进阶-2">进阶</h4><ul>
<li><code>Ctrl-W r</code>  向下/向右移动窗口</li>
<li><code>Ctrl-W R</code> 向上/向左移动窗口</li>
<li><code>Ctrl-W K</code> 移动到最顶端，宽度满屏</li>
<li><code>Ctrl-W J</code> 移动到最低，宽度满屏   Ctrl-W H 和 Ctrl-W L 与之同理，分别移动到最左最右 </li>
<li><code>Ctrl-W =</code> 均分窗口</li>
<li><code>Ctrl-W t Ctrl-W K</code>    将两个垂直分割变为水平分割 </li>
<li><code>Ctrl-W t Ctrl-W H</code>    将两个水平分割变为垂直分割</li>
<li><code>Ctrl-W Shift-T</code>    将窗口移动到tab中 </li>
<li><code>Ctrl-W t</code> makes the first (topleft) window current Ctrl-W K moves the current window to full-width at the very top </li>
<li><code>Ctrl-W H</code> moves the current window to full-height at far left</li>
<li><code>Ctrl - W R</code>  向右移动</li>
</ul>
<h3 id="tab">tab</h3><h4 id="基础-4">基础</h4><ul>
<li><code>gt</code> 向左移动</li>
<li><code>gT</code> 向右移动</li>
<li><code>ngt</code>  移动到第n个</li>
</ul>
<h4 id="进阶-3">进阶</h4><ul>
<li><code>:tabm n</code> 移动当前tab的位置，如果要将tab的位置移动到最后，可以输一个足够大的值 tabm 99 就可以移动到最后了 tabm 0移动到最前</li>
<li><code>:tabonly</code> 关闭其他窗口</li>
</ul>
<h2 id="内容查找替换"><a href="http://vim.wikia.com/wiki/Searching%20" target="_blank" rel="external">内容查找替换</a></h2><h3 id="文件内查找替换">文件内查找替换</h3><p>[addr]s/源字符串/目的字符串/[option]</p>
<p>[addr] 表示检索范围，省略时表示当前行。如：“1，20” ：表示从第1行到20行；“%” ：表示整个文件，同“1,$”；“. ,$” ：从当前行到文件尾；<br>[option] : 表示操作类型   如：g 表示全局替换; c 表示进行确认 p 表示替代结果逐行显示（Ctrl + L恢复屏幕）； </p>
<pre><code>`<span class="symbol">:%s/foo/bar/g`</span> 将整个文件中的foo替换为bar，不需要确认
`<span class="symbol">:%s/</span>\s\+<span class="variable">$/</span>/` 删除每一行后面多余的空格
</code></pre><p>###跨文件文件查找</p>
<p>使用：<code>vimgrep  /{pattern}/[g][j]   files</code></p>
<p>例如:查找目录pulibc/js下的文件中是否有 function1<br><code>vimgrep  /function1/  ./public/js/**/*.js</code></p>
<p><code>:copen</code> 打开quickfix</p>
<h4 id="快捷键">快捷键</h4><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">:cprev[ious]:</span> [q</span><br><span class="line"><span class="attribute">:cnext:</span>       ]q</span><br><span class="line"><span class="attribute">:cfirst:</span>      [Q</span><br><span class="line"><span class="attribute">:clast:</span>       ]Q</span><br></pre></td></tr></table></figure>
<p>参考</p>
<ol>
<li><a href="http://vim.wikia.com/wiki/Quick_tips_for_using_tab_pages" target="_blank" rel="external">tab使用秘籍</a></li>
</ol>
<h2 id="参见问题">参见问题</h2><h3 id="如何批量生产字符串?">如何批量生产字符串?</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:put =<span class="function"><span class="title">range</span><span class="params">(<span class="number">11</span>,<span class="number">15</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="function"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="title">range</span>(<span class="params"><span class="number">1</span>,<span class="number">10</span></span>) | put </span>=<span class="string">'192.168.0.'</span>.i | endfor</span><br></pre></td></tr></table></figure>
<p>生成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.3</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.4</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.5</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.6</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.7</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.9</span></span><br><span class="line"><span class="number">192.168</span><span class="number">.0</span><span class="number">.10</span></span><br></pre></td></tr></table></figure>
<p><a href="http://vim.wikia.com/wiki/Making_a_list_of_numbers" target="_blank" rel="external">参考</a></p>
<p>###如何定义快捷键</p>
<figure class="highlight"><figcaption><span><f5> i&#123;e<esc>a&#125;<esc>```</esc></esc></f5></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;`i&#123;` &#23558;&#25554;&#20837;&#23383;&#31526;`&#123;`&#65292;&#28982;&#21518;&#20351;&#29992;Esc&#36864;&#22238;&#21040;&#21629;&#20196;&#29366;&#24577;&#65307;&#25509;&#30528;&#29992;e&#31227;&#21040;&#21333;&#35789;&#32467;&#23614;&#65292;a&#125;&#22686;&#21152;&#23383;&#31526;&#125;&#65292;&#26368;&#21518;&#36864;&#33267;&#21629;&#20196;&#29366;&#24577;&#12290;&#22312;&#25191;&#34892;&#20197;&#19978;&#21629;&#20196;&#20043;&#21518;&#65292;&#20809;&#26631;&#23450;&#20301;&#22312;&#19968;&#20010;&#21333;&#35789;&#19978;&#65288;&#20363;&#22914;amount&#65289;&#65292;&#25353;&#19979;F5&#38190;&#65292;&#36825;&#26102;&#23383;&#31526;&#23601;&#20250;&#21464;&#25104;&#123;amount&#125;&#30340;&#24418;&#24335;&#12290;&#10;&#10;&#20351;&#29992;&#20197;&#19979;&#21629;&#20196;&#65292;&#21487;&#20197;&#22312;Normal Mode&#21644;Visual/Select Mode&#19979;&#65292;&#21033;&#29992;Tab&#38190;&#21644;Shift-Tab&#38190;&#26469;&#32553;&#36827;&#25991;&#26412;&#65306;</span><br></pre></td></tr></table></figure>
<p>nmap <tab> V&gt;<br>nmap <s-tab> V&lt;<br>vmap <tab> &gt;gv<br>vmap <s-tab> <gv <figure="" class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用以下命令，指定F10键来新建标签页：</span><br></pre></td></tr></table></gv></s-tab></tab></s-tab></tab></p>
<p>:map <f10> <esc>:tabnew<cr><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></cr></esc></f10></p>
<ul>
<li>:nmap - Display normal mode maps</li>
<li>:imap - Display insert mode maps</li>
<li>:vmap - Display visual and select mode maps</li>
<li>:smap - Display select mode maps</li>
<li>:xmap - Display visual mode maps</li>
<li>:cmap - Display command-line mode maps</li>
<li><p>:omap - Display operator pending mode maps</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">参考: (给vim自定义快捷键)[http://www.pythonclub.org/linux/vim/map]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">###如何重新reload .vimrc文件?</span></span><br><span class="line"></span><br><span class="line">如果当前编辑的就是.vimrc文件  <span class="code">`:so %`</span></span><br><span class="line"></span><br><span class="line">如果不是 <span class="code">`:so `</span></span><br><span class="line"></span><br><span class="line"><span class="header">###什么是filetype</span></span><br><span class="line"><span class="code">     </span></span><br><span class="line">[<span class="link_label">refer</span>](<span class="link_url">http://vimdoc.sourceforge.net/htmldoc/filetype.html</span>)</span><br><span class="line"></span><br><span class="line"><span class="header">###如何在split window打开buffer列表中的buffer</span></span><br><span class="line"></span><br><span class="line"><span class="code">`:vert sb N`</span> (N是buffer序号)</span><br><span class="line"><span class="code">`:vert belowright sb N`</span>  在右边split打开，默认是左边 </span><br><span class="line"></span><br><span class="line"><span class="header">###如何设置 tab 和 space的展现形式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">###黏贴的时候不要自动indent</span></span><br><span class="line"></span><br><span class="line">黏贴前运行 command <span class="code">`:set pastell`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">###如何设置tab</span></span><br><span class="line"></span><br><span class="line">http://tedlogan.com/techblog3.html</span><br><span class="line"></span><br><span class="line"><span class="header">### 神马是Compatible mode</span></span><br><span class="line">http://superuser.com/questions/543317/what-is-compatible-mode-in-vim</span><br><span class="line"></span><br><span class="line"><span class="header">### 如何控制縮進</span></span><br></pre></td></tr></table></figure>
<p>n&gt;&gt;  將n行同時縮進  n&lt;&lt;同理</p>
<blockquote>
<p>% 縮進curly braces{}包裹的區域 &lt;％ton</p>
<ng 235839="" 縮進當前行到第n行的內容="" i{="" 縮進inner="" block="" <i{="" 同理="" http:="" stackoverflow.com="" questions="" how-do-i-indent-multiple-lines-quickly-in-vi="" <figure="" class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### 如何在Vim使用鼠标？</span></span><br></pre></td></tr></table>

</ng></blockquote>
<p> set mouse=a<br> 参考：<a href="http://usevim.com/2012/05/16/mouse/" target="_blank" rel="external">http://usevim.com/2012/05/16/mouse/</a>  </p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="header">### 如何显示多余的空格</span></span><br><span class="line"></span><br><span class="line">那么可以在vimrc 中使用下面这段代码</span><br><span class="line">[<span class="link_label">参考</span>](<span class="link_url">http://vim.wikia.com/wiki/Highlight_unwanted_spaces</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">### 如何维护函数不超过 80行</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>let &amp;colorcolumn=join(range(81,999),”,”)<br>let &amp;colorcolumn=”80,”.join(range(120,999),”,”)<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="link_label">参考</span>](<span class="link_url">http://stackoverflow.com/questions/2447109/showing-a-different-background-colour-in-vim-past-80-characters</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="header">## 組合技</span></span><br><span class="line"></span><br><span class="line"><span class="header">### 常用</span></span><br><span class="line"><span class="bullet">* </span>xp 字符互换</span><br><span class="line"><span class="bullet">* </span>ddp 上下行换行</span><br><span class="line"><span class="bullet">* </span><span class="code">`$ a`</span> <span class="code">`$`</span> 跳到行尾，<span class="code">`a`</span> 在最后位置开始输入</span><br><span class="line"><span class="bullet">* </span><span class="code">`gg“+yG`</span>    将文件内容复制到剪贴版  <span class="code">`gg`</span>跳到第一行  <span class="code">`“+`</span> 选择存放的寄存器  <span class="code">`yG`</span>复制所有行数</span><br><span class="line"><span class="bullet">* </span>visual模式下</span><br><span class="line"><span class="code">    * `a(   a)   ab`  选择括号和括号里面的内容   ( content )</span></span><br><span class="line"><span class="code">    * `i(   i)   ib` 选择括号里面的内容       ( content ) </span></span><br><span class="line"><span class="code">    * `‘  “  [`  这些都可以与上同理 例如  `i’` 选择单引号里面的内容，`a[` 选择中括号和中括号里面的内容</span></span><br><span class="line"><span class="bullet">* </span>ciw 改变单词</span><br><span class="line"><span class="bullet">* </span>caw 改变光标所在的完整一个单词</span><br><span class="line"></span><br><span class="line"><span class="header">## 插件列表</span></span><br><span class="line"></span><br><span class="line"><span class="header">### my bundle list</span></span><br></pre></td></tr></table></figure></p>
<p>Bundle ‘gmarik/vundle’<br>Bundle ‘tpope/vim-fugitive’<br>Bundle ‘Lokaltog/vim-easymotion’<br>Bundle ‘tpope/vim-rails.git’<br>Bundle ‘rstacruz/sparkup’, {‘rtp’: ‘vim/‘}<br>Bundle ‘L9’<br>Bundle ‘FuzzyFinder’<br>Bundle ‘scrooloose/nerdtree’<br>Bundle ‘Lokaltog/vim-powerline’<br>Bundle ‘scrooloose/syntastic’<br>Bundle ‘kien/ctrlp.vim’<br>Bundle ‘kchmck/vim-coffee-script’<br>Bundle ‘tpope/vim-unimpaired’<br>Bundle ‘SirVer/ultisnips’<br>Bundle ‘honza/vim-snippets’<br>Bundle ‘majutsushi/tagbar’<br>Bundle ‘ervandew/supertab’<br>Bundle ‘Shougo/neocomplcache.vim’<br>Bundle ‘terryma/vim-multiple-cursors’<br>Bundle ‘Raimondi/delimitMate’<br>Bundle ‘tpope/vim-surround’<br>Bundle ‘EasyGrep’<br>Bundle ‘mileszs/ack.vim’<br>Bundle ‘tyok/nerdtree-ack’<br>```</p>
<h3 id="相关介绍">相关介绍</h3><ul>
<li>vim-scripts/Visual-Mark  <a href="https://github.com/vim-scripts/Visual-Mark/" target="_blank" rel="external">https://github.com/vim-scripts/Visual-Mark/</a>      </li>
<li>kien/ctrlp.vim   <a href="https://github.com/kien/ctrlp.vim" target="_blank" rel="external">https://github.com/kien/ctrlp.vim</a>  轻量级的文件切换工具 </li>
<li>SirVer/ultisnips  <a href="https://github.com/SirVer/ultisnips" target="_blank" rel="external">https://github.com/SirVer/ultisnips</a>    神级插件 <a href="http://fueledbylemons.com/blog/2011/07/27/why-ultisnips/" target="_blank" rel="external">http://fueledbylemons.com/blog/2011/07/27/why-ultisnips/</a>  </li>
<li>terryma/vim-multiple-cursors   实现Sublime的Ctrl-D功能 多行同时编辑</li>
<li>tpope/vim-unimpaired   可以方便的执行<code>:lprev ( [l ), :lne( ]l )</code>的命令，还有可以实现移动行  [e ]e 类似于Sublime的 移动行 </li>
<li>tpope/commentary.vim  注释插件</li>
<li>tabular 方便文本对齐 <a href="https://github.com/godlygeek/tabular" target="_blank" rel="external">https://github.com/godlygeek/tabular</a></li>
<li>Ack 搜索关键词 <a href="https://github.com/mileszs/ack.vim" target="_blank" rel="external">https://github.com/mileszs/ack.vim</a> </li>
<li>mru <a href="https://github.com/yegappan/mru" target="_blank" rel="external">https://github.com/yegappan/mru</a> 最近打开的文件</li>
<li>heavenshell/vim-jsdoc <a href="https://github.com/heavenshell/vim-jsdoc" target="_blank" rel="external">github</a></li>
<li>tyok/nerdtree-ack  将nerdTree和ack结合起来，实现文件夹搜索</li>
</ul>
<h2 id="资料">资料</h2><ol>
<li><a href="http://stackoverflow.com/questions/1218390/what-is-your-most-productive-shortcut-with-vim/1220118220118" target="_blank" rel="external">What is your most productive shortcut with Vim?</a></li>
<li><a href="http://bytefluent.com/vivify/" target="_blank" rel="external">Vim代码高亮主题</a></li>
<li><a href="http://vim.wikia.com/wiki/Best_Vim_Tips" target="_blank" rel="external">Best Vim Tips</a></li>
<li><a href="https://github.com/joyent/node/wiki/Vim-Plugins" target="_blank" rel="external">Vim Plugins</a></li>
<li><a href="http://vim.wikia.com/wiki/Use_Vim_like_an_IDE" target="_blank" rel="external">Use Vim like an IDE</a></li>
<li><a href="http://overapi.com/vim/" target="_blank" rel="external">VIM的各种助记图，可以作为桌面</a></li>
<li><a href="http://wdicc.com/search-in-vim/" target="_blank" rel="external">VIM查找替换归纳总结</a></li>
<li><a href="http://blog.hugeaim.com/2012/05/11/find-in-folder-in-vim-with-nerdtree-and-ack/" target="_blank" rel="external">文件夹查找插件</a></li>
</ol>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/default_avatar.jpg" alt="Andrew Zhang" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Andrew Zhang</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">28</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andrew Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
