<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Code Me</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Code Me">
<meta property="og:url" content="http://zhangmhao.github.io/page/2/index.html">
<meta property="og:site_name" content="Code Me">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Code Me">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Code Me" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://www.gravatar.com/avatar/fb8601449879167556af06aa6a895cd4?s=300" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Andrew Zhang</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/github.com/zhangmhao" title="github">github</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Com/" style="font-size: 10px;">Com</a> <a href="/tags/api/" style="font-size: 10px;">api</a> <a href="/tags/cookie/" style="font-size: 10px;">cookie</a> <a href="/tags/css/" style="font-size: 10px;">css</a> <a href="/tags/haskell/" style="font-size: 10px;">haskell</a> <a href="/tags/html5/" style="font-size: 10px;">html5</a> <a href="/tags/http协议/" style="font-size: 10px;">http协议</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/node/" style="font-size: 10px;">node</a> <a href="/tags/nwjs/" style="font-size: 10px;">nwjs</a> <a href="/tags/restful/" style="font-size: 10px;">restful</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/交互设计/" style="font-size: 10px;">交互设计</a> <a href="/tags/前端开发/" style="font-size: 10px;">前端开发</a> <a href="/tags/前端性能优化/" style="font-size: 17.5px;">前端性能优化</a> <a href="/tags/回调/" style="font-size: 10px;">回调</a> <a href="/tags/复杂系统/" style="font-size: 10px;">复杂系统</a> <a href="/tags/工具开发/" style="font-size: 10px;">工具开发</a> <a href="/tags/心理学/" style="font-size: 10px;">心理学</a> <a href="/tags/性能优化/" style="font-size: 12.5px;">性能优化</a> <a href="/tags/总结/" style="font-size: 12.5px;">总结</a> <a href="/tags/时间管理/" style="font-size: 12.5px;">时间管理</a> <a href="/tags/模块化/" style="font-size: 10px;">模块化</a> <a href="/tags/生活优化/" style="font-size: 10px;">生活优化</a> <a href="/tags/组件化/" style="font-size: 10px;">组件化</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a> <a href="/tags/设计/" style="font-size: 10px;">设计</a> <a href="/tags/设计文档/" style="font-size: 12.5px;">设计文档</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">探索这个太有趣的世界</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Andrew Zhang</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://www.gravatar.com/avatar/fb8601449879167556af06aa6a895cd4?s=300" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Andrew Zhang</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/github.com/zhangmhao" title="github">github</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-Node错误处理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/10/24/Node错误处理/" class="article-date">
  	<time datetime="2014-10-23T16:00:00.000Z" itemprop="datePublished">2014-10-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/10/24/Node错误处理/">Node错误处理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在写一个个人项目，错误处理的代码写的比较混乱，读到一个博客的文章，按照这个方法进行处理，错误处理代码不至于乱成一窝粥。记录些阅读笔记:</p>
<h3 id="Operational_errors_vs-_programmer_errors">Operational errors vs. programmer errors</h3><blockquote>
<p>Learn to distinguish between operational errors, which are anticipatable, unavoidable errors, even in correct programs (e.g., failing to connect to a server), and programmer errors, which are bugs in the program.Operational errors can and should be handled. Programmer errors cannot be handled or reliably recovered from (nor should they be), and attempting to do so makes them harder to debug.</p>
</blockquote>
<h4 id="Operational_errors">Operational errors</h4><p>Operational errors represent run-time problems experienced by correctly-written programs. These are not bugs in the program. </p>
<p>Examples:</p>
<ul>
<li>failed to connect to server</li>
<li>failed to resolve hostname</li>
<li>invalid user input</li>
<li>request timeout</li>
<li>server returned a 500 response</li>
<li>socket hang-up</li>
<li>system is out of memory</li>
</ul>
<h4 id="Programmer_errors">Programmer errors</h4><p>Programmer errors are bugs in the program. These are things that can always be avoided by changing the code</p>
<p>Example:</p>
<ul>
<li>调用函数过程传递错误的参数</li>
<li>tried to read property of “undefined”</li>
<li>called an asynchronous function without a callback</li>
</ul>
<h4 id="Handling_operational_errors">Handling operational errors</h4><blockquote>
<p>Nor can you centralize all error handling in one part of the program, the same way you can’t centralize “performance” in one part of the program. </p>
</blockquote>
<ul>
<li><strong>Deal with the failure directly</strong> 例如<code>文件不存在</code>就创建该文件，<code>访问失败</code>则重试</li>
<li><strong>Propagate the failure to your client</strong>. If you don’t know how to deal with the error, the simplest thing to do is to abort whatever operation you’re trying to do, clean up whatever you’ve started, and deliver an error back to your client.</li>
<li><strong>Retry the operation</strong> If you’re several layers deep in the stack (e.g., you’re being called by a client, which was called by another client, which is being driven by a human), it’s usually better to fail fast and let the end client deal with retries. If every layer of the stack thinks it needs to retry on errors, the user can end up waiting much longer than they should because because each layer didn’t realize that the underlying layer was also retrying.</li>
<li><strong>Log the error</strong> — and do nothing else</li>
</ul>
<p>##参考</p>
<ol>
<li><a href="https://www.joyent.com/developers/node/design/errors" target="_blank" rel="external">https://www.joyent.com/developers/node/design/errors</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/Nodejs/">Nodejs</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-Restful-API" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/09/12/Restful-API/" class="article-date">
  	<time datetime="2014-09-11T16:00:00.000Z" itemprop="datePublished">2014-09-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/09/12/Restful-API/">RESTful学习笔记</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是RESTful架构：">什么是RESTful架构：</h3><p>Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。</p>
<h4 id="资源（Resources）">资源（Resources）</h4><p>网络上的一个实体，它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。</p>
<h4 id="表现层（Representation）">表现层（Representation）</h4><p>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。”资源”是一种信息实体，它可以有多种外在表现形式。比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现。URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p>
<h4 id="状态转化（State_Transfer）">状态转化（State Transfer）</h4><p>客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 </p>
<p>这里引用阮一峰的总结：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 每一个URI代表一种资源；</span><br><span class="line"><span class="number">2.</span> 客户端和服务器之间，传递这种资源的某种表现层；</span><br><span class="line"><span class="number">3.</span> 客户端通过四个HTTP动词，对服务器端资源进行操作，实现<span class="string">"表现层状态转化"</span></span><br></pre></td></tr></table></figure>
<h3 id="实例">实例</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /zoos：列出所有动物园</span><br><span class="line">POST /zoos：新建一个动物园</span><br><span class="line">GET <span class="regexp">/zoos/</span>ID：获取某个指定动物园的信息</span><br><span class="line">PUT <span class="regexp">/zoos/</span>ID：更新某个指定动物园的信息（提供该动物园的全部信息）</span><br><span class="line">PATCH <span class="regexp">/zoos/</span>ID：更新某个指定动物园的信息（提供该动物园的部分信息）</span><br><span class="line">DELETE <span class="regexp">/zoos/</span>ID：删除某个动物园</span><br><span class="line">GET <span class="regexp">/zoos/</span>ID/animals：列出某个指定动物园的所有动物</span><br><span class="line">DELETE <span class="regexp">/zoos/</span>ID<span class="regexp">/animals/</span>ID：删除某个指定动物园的指定动物</span><br></pre></td></tr></table></figure>
<h3 id="RESTful架构有一些典型的设计误区">RESTful架构有一些典型的设计误区</h3><p>最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。<br>另一个设计误区，就是在URI中加入版本号：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　<span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.0/foo</span></span><br><span class="line">　<span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/1.1/foo</span></span><br><span class="line">　<span class="symbol">http:</span>/<span class="regexp">/www.example.com/app</span><span class="regexp">/2.0/foo</span></span><br></pre></td></tr></table></figure>
<p>因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Accep<span class="variable">t:</span> vnd.example-<span class="keyword">com</span>.foo+json; <span class="keyword">version</span>=<span class="number">1.0</span></span><br><span class="line">Accep<span class="variable">t:</span> vnd.example-<span class="keyword">com</span>.foo+json; <span class="keyword">version</span>=<span class="number">1.1</span></span><br><span class="line">Accep<span class="variable">t:</span> vnd.example-<span class="keyword">com</span>.foo+json; <span class="keyword">version</span>=<span class="number">2.0</span></span><br></pre></td></tr></table></figure>
<h3 id="RESTful_API最好做到Hypermedia">RESTful API最好做到Hypermedia</h3><p>例子:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">link</span>": <span class="value">&#123;</span><br><span class="line">        "<span class="attribute">rel</span>":   <span class="value"><span class="string">"collection https://www.example.com/zoos"</span></span>,</span><br><span class="line">        "<span class="attribute">href</span>":  <span class="value"><span class="string">"https://api.example.com/zoos"</span></span>,</span><br><span class="line">        "<span class="attribute">title</span>": <span class="value"><span class="string">"List of zoos"</span></span>,</span><br><span class="line">        "<span class="attribute">type</span>":  <span class="value"><span class="string">"application/vnd.yourformat+json"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>
<p>实际例子可以看<a href="https://api.github.com/" target="_blank" rel="external">Github API</a></p>
<h2 id="参考">参考</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">RESTful API 设计指南</a></li>
<li><a href="http://codeplanet.io/principles-good-restful-api-design/" target="_blank" rel="external">Principles of good RESTful API Design</a></li>
<li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1" target="_blank" rel="external">http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/restful/">restful</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/前端开发/">前端开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-探索如何管理API" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/07/12/探索如何管理API/" class="article-date">
  	<time datetime="2014-07-11T16:00:00.000Z" itemprop="datePublished">2014-07-12</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/07/12/探索如何管理API/">探索API管理的可行方案</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="为什么要管理接口？">为什么要管理接口？</h3><p>开发过程中，前端和后端耦合的部分就在于接口的联调，如果没有一份详细并且清晰准确的文档，沟通成本往往会大大的增加，再加上沟通流畅度的影响（开发人员不在同一个办公地点），还有，很重要的一点是：到要保证准确就必须保证文档和实际接口代码的同步，对于繁（懒）忙（惰）的程序员来讲，这个是无法100%保证的。而对于这一点，仅仅建立一份文档是远远不够的，因为这里涉及到人的因数，而人往往是系统当中最不靠谱的，稳定性最差的模块。如果你不想成为这种机械工作中的一个模块，就必须想出更好的办法来管理接口。</p>
<p>这里先总结一下，如果缺少有效的接口管理，会有以下坏处：</p>
<ul>
<li>沟通成本高</li>
<li>容易出错</li>
</ul>
<p>而以上两点导致一个终极的问题：<strong>生命的浪费</strong>，没有人愿意将时间花在无谓的事情之上。目前在接口管理上又那些痛点呢？</p>
<h3 id="痛点">痛点</h3><h4 id="1-_编写接口文档较为繁琐">1. 编写接口文档较为繁琐</h4><ul>
<li>文档格式不统一<br>各个团队没有一份统一的文档格式，不方便不同团队之间的合作和交流。</li>
<li>静态文本的编辑成本高<br>文本的格式化，代码的高亮等等</li>
</ul>
<h4 id="2-_维护文档更难">2. 维护文档更难</h4><p>维护文档的主要工作就是保持接口文档和代码的一致性，如果代码发生改变而文档没有更新，那么依旧是有一定的沟通成本。</p>
<h4 id="3-_接口文档的难以管理">3. 接口文档的难以管理</h4><p>有了文档之后，要查阅，要修改，要归类，要分版本。这些都是需要一个平台来进行支撑，而不仅仅是用一份静态文本就可以解决的</p>
<h4 id="4-_接口测试难">4. 接口测试难</h4><p>在平时的开发中，前端和后端定好了接口协议之后就并行进行开发，有的是前端自己模拟数据，有的是使用后端的模拟数据。等到后端接口开发完成之后，就将真实接口来替换模拟数据的接口。在这里有两种情形：</p>
<ol>
<li>使用后端提供的模拟数据，工作量在后端</li>
<li>前端自己模拟数据，工作量在前端，需要将访问接口切换为真实数据</li>
</ol>
<p>自己对情形1不熟悉，这里先谈情形2，后端接口完成之后，前端进行接口替换，验证方式类似冒烟测试，如果时间充裕，就会验证的仔细，时间不充裕，则有可能会忽略掉实际接口和接口文档中的部分细微差别。这里依靠人工的验证方式，不仅效率低下，而且容易出错。解决的办法就是提供接口的单元测试和回归测试。每一个接口的定义就是一个测试用例，接口完成之后可以借助单元测试正确高效的验证接口的正确性。而每一次对接口的修改，都可以进行回归测试，验证接口的修改是否会引起系统的错误。</p>
<h4 id="5-_对接口文档的重视度不足">5. 对接口文档的重视度不足</h4><p>我见过部分团队接口文档都给省了，直接口头交流。当然会沟通成本过高。但是问其为何不用接口文档，他们就是觉得写接口文档太麻烦了，维护也麻烦。也就是说，接口文档编写维护成本高，这已经是一个门槛了，再加上看不到接口文档带来的效益，所以他们宁愿采取低效的口头交流。<br>而有的团队还是会编写接口文档，但是随着项目的迭代，很多的接口文档都无法跟上代码的脚步。</p>
<p>好，现在针对这些痛点来进行平台的设计</p>
<ul>
<li>编写难</li>
<li>维护难</li>
<li>测试难</li>
</ul>
<h3 id="系统设计">系统设计</h3><h4 id="1-_接口管理">1. 接口管理</h4><h5 id="1-1_可视化编辑">1.1 可视化编辑</h5><p>降低编写成本，写接口就像写对象图。</p>
<p>一般接口文档是如何描述接口的呢？</p>
<p>非RestFul风格：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">URL: /getTodoList</span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span> GET</span><br><span class="line"><span class="keyword">desc</span>: 获取Todo列表，<span class="keyword">type</span>参数进行过滤，已有类型</span><br><span class="line">    已完成: done</span><br><span class="line">    已删除: delete</span><br><span class="line">    代办: todo</span><br><span class="line">如果不传表示不过滤</span><br><span class="line"><span class="keyword">params</span>:</span><br><span class="line">    <span class="keyword">type</span> <span class="comment">&#123;required&#125;</span><span class="comment">&#123;string&#125;</span> done/todo/delete</span><br><span class="line">example:</span><br><span class="line">    /getTodo?id=<span class="number">23</span>ef</span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">URL: /getTodo</span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span> GET</span><br><span class="line"><span class="keyword">desc</span>: 获取todo的详情</span><br><span class="line"><span class="keyword">params</span>:</span><br><span class="line">    id <span class="comment">&#123;required&#125;</span><span class="comment">&#123;string&#125;</span> Todo项目的ID</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">    /getTodo?id=<span class="number">23</span>ef</span><br><span class="line"></span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">URL: /saveTodo</span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span> POST</span><br><span class="line"><span class="keyword">desc</span>: 保存Todo</span><br><span class="line"><span class="keyword">params</span>:</span><br><span class="line">    id  <span class="comment">&#123;string&#125;</span><span class="comment">&#123;required&#125;</span> ID</span><br><span class="line">    title  <span class="comment">&#123;string&#125;</span><span class="comment">&#123;required&#125;</span> 标题</span><br><span class="line">    note <span class="comment">&#123;string&#125;</span> 备注</span><br><span class="line">    </span><br><span class="line">-----------------------------------------------</span><br><span class="line"></span><br><span class="line">URL: /createTodo</span><br><span class="line"><span class="function"><span class="keyword">method</span>:</span> POST</span><br><span class="line"><span class="keyword">desc</span>: 创建Todo</span><br><span class="line"><span class="keyword">params</span>:</span><br><span class="line">    title  <span class="comment">&#123;string&#125;</span><span class="comment">&#123;required&#125;</span> 标题</span><br><span class="line">    note <span class="comment">&#123;string&#125;</span> 备注</span><br></pre></td></tr></table></figure>
<p>上面这一份文档存在的问题</p>
<ul>
<li><p>可读性差<br>视觉上侧重点不突出，缺乏关注点，不够一目了然。如果要在视觉上进行处理，就必须要有文本格式化，这个如果人工进行维护，是比较麻烦的</p>
</li>
<li><p>可维护性差<br>如果要进行修改，对于新人则需要先学习文档的格式和各种标志位{required}{string}之类的，然后才能进行修改。有一定的学习曲线。</p>
</li>
<li><p>无法进行过滤，搜索<br>例如我仅仅想查看接口中的required变量，或者我要过滤出POST类型接口，我想根据接口名进行过滤</p>
</li>
</ul>
<p>而可视化编辑和更友好的管理界面(解决搜索过滤问题)就是要解决这种问题</p>
<h5 id="1-2_接口实现进度">1.2 接口实现进度</h5><p>可是查看接口实现进度</p>
<p>一旦接口可以访问，且数据正确，则表示该接口以完成。</p>
<h5 id="1-3_接口版本管理">1.3 接口版本管理</h5><p>每一次对接口的修改都可以有一个对应的版本号。接口使用方可以指定对应的版本访问不同版本的数据，例如:</p>
<pre><code>`/<span class="number">1.1</span><span class="number">.0</span>/todo/<span class="number">23</span>ef`  返回<span class="number">1.1</span><span class="number">.0</span>版本的数据
`/<span class="number">1.2</span><span class="number">.0</span>/todo/<span class="number">23</span>ef`  返回<span class="number">1.2</span><span class="number">.0</span>版本的数据
</code></pre><h4 id="2-_Mock数据">2. Mock数据</h4><p>设计好接口之后，为了前后端可以并行开发，就需要先提供模拟数据。一般来讲，不是后端提供，就是前端自己模拟数据，无论使用哪一种方式，都得自己去造数据。这也是一个耗时的地方。那么，该如何改进呢？</p>
<p>一旦使用APIE系统添加完接口之后，就可以根据接口描述来自动造数据<br>例如一个todo系统的接口描述为</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">todo: &#123;</span><br><span class="line">    <span class="keyword">desc</span>: <span class="string">'todo项目'</span>,</span><br><span class="line">    apis: [&#123;</span><br><span class="line">        name: <span class="string">'todos'</span>,</span><br><span class="line">        <span class="keyword">desc</span>: <span class="string">'获取todo列表'</span>,</span><br><span class="line">        uri: <span class="string">'todos'</span>,</span><br><span class="line">        method: <span class="string">'GET'</span>,</span><br><span class="line">        parameters: [],</span><br><span class="line">        model: &#123;</span><br><span class="line">            id: &#123;</span><br><span class="line">                type: <span class="string">'number'</span>,</span><br><span class="line">                <span class="keyword">desc</span>: <span class="string">'id'</span>,</span><br><span class="line">                required: <span class="keyword">true</span></span><br><span class="line">            &#125;</span><br><span class="line">            title: &#123;</span><br><span class="line">                type: <span class="string">'string'</span>,</span><br><span class="line">                <span class="keyword">desc</span>: <span class="string">'标题'</span>,</span><br><span class="line">                required: <span class="keyword">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            note: &#123;</span><br><span class="line">                type: <span class="string">'string'</span>,</span><br><span class="line">                <span class="keyword">desc</span>: <span class="string">'备注'</span></span><br><span class="line">            &#125;,</span><br><span class="line">            done: &#123;</span><br><span class="line">                type: <span class="string">'boolean'</span>,</span><br><span class="line">                <span class="keyword">desc</span>: <span class="string">'已完成'</span>,</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自动造数据, 接口<code>/todos</code>返回:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    success: <span class="literal">true</span>,</span><br><span class="line">    data: [&#123;</span><br><span class="line">        id: <span class="string">'23ef'</span>,</span><br><span class="line">        title: <span class="string">'this is a title 1'</span>,</span><br><span class="line">        note: <span class="string">'this is a note 1'</span>,</span><br><span class="line">        <span class="keyword">done</span>: <span class="literal">false</span></span><br><span class="line">    &#125;, &#123;</span><br><span class="line">        id: <span class="string">'23f0'</span>,</span><br><span class="line">        title: <span class="string">'this is a title 2'</span>,</span><br><span class="line">        note: <span class="string">''</span>,</span><br><span class="line">        <span class="keyword">done</span>: <span class="literal">true</span></span><br><span class="line">    &#125;, ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口<code>/todos/23ef</code></p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    success: <span class="literal">true</span>,</span><br><span class="line">    <span class="built_in">data</span> <span class="built_in">data</span>: <span class="preprocessor">[</span>&#123;</span><br><span class="line">        id: <span class="string">'23ef'</span>,</span><br><span class="line">        title: <span class="string">'this is a title 1'</span>,</span><br><span class="line">        note: <span class="string">'this is a note 1'</span>,</span><br><span class="line">        done: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到，上面的数据是一种不包含业务细节的数据模拟<code>this is a title 1</code>之类的数据不够真实。那么该如何让系统更加真实呢？前期暂时没有一个太好的规划，目前的想法是通过用户自己录入数据，或者系统自身先<strong>预置一部分数据</strong>。例如email,address,url之类是可以模拟出来的。业务方面也可以<strong>通过学习用户自定义的数据</strong>来增加系统的经验，例如如果有系统定义了浏览器平台，且添加了一些自定义模拟数据。则将这些模拟数据添加到模拟数据的数据库中。</p>
<h4 id="3-_接口测试">3. 接口测试</h4><h5 id="3-1_单元测试">3.1 单元测试</h5><h5 id="3-2_回归测试">3.2 回归测试</h5><h4 id="4-_网络环境的模拟">4. 网络环境的模拟</h4><h5 id="4-1_常用环境(2G,3G,wifi,4G)">4.1 常用环境(2G,3G,wifi,4G)</h5><p>通过收集运行商网速数据来进行模拟<br>返回数据的时间:</p>
<p>$$ rtt = \dfrac{dataSize}{speed} $$</p>
<p>rtt: roadtrip time</p>
<h5 id="4-2_自定义网速">4.2 自定义网速</h5><p>不同时间段可以有不同的速度</p>
<hr>
<h3 id="代码的双向同步">代码的双向同步</h3><p>来模拟一下这一个过程：</p>
<p>现在平台上进行编辑,</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Message [messages/&#123;id&#125;]</span></span><br><span class="line">This resource represents one particular message identified by its <span class="keyword">*</span>id<span class="keyword">*</span>.</span><br><span class="line"><span class="comment">## Retrieve Message [GET]</span></span><br><span class="line">Retrieve a message by its <span class="keyword">*</span>id<span class="keyword">*</span>.</span><br><span class="line"></span><br><span class="line">+ Response 200 (text/plain)</span><br><span class="line"></span><br><span class="line">        Hello World!</span><br><span class="line"></span><br><span class="line"><span class="comment">## Delete Message [DELETE]</span></span><br><span class="line">Delete a message. <span class="keyword">*</span><span class="keyword">*</span>Warning:<span class="keyword">*</span><span class="keyword">*</span> This action <span class="keyword">*</span><span class="keyword">*</span>permanently<span class="keyword">*</span><span class="keyword">*</span> removes the message from the database.</span><br><span class="line"></span><br><span class="line">+ Response 204</span><br></pre></td></tr></table></figure>
<p>上面定义了api如 <code>messages/1</code> 接口</p>
<p>代码中只要添加对应的标识符</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@apie</span> [messages/&#123;id&#125; GET]</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMessage</span><span class="params">(id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后如果有代码库权限，则平台可以进行代码分析。找出文档和代码的差异，进而进行同步，如果文档发生改变，而代码没有发生改变，则平台进行提醒，用户自行修改，如果代码发生改变，而文档没有变，则进行提示，代码发生改变，是否进行代码同步。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计文档/">设计文档</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/开发/">开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-代码整洁之道(读书笔记)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/26/代码整洁之道(读书笔记)/" class="article-date">
  	<time datetime="2014-06-25T16:00:00.000Z" itemprop="datePublished">2014-06-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/26/代码整洁之道(读书笔记)/">代码整洁之道(读书笔记)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-_整洁代码">1. 整洁代码</h2><h4 id="什么样的代码算是整洁？">什么样的代码算是整洁？</h4><ul>
<li>只做好一件事情</li>
<li>没有重复代码</li>
<li>代码逻辑直接了当，只包含必须的代码</li>
<li>尽可能少的依赖关系，便于维护</li>
<li>明确的定义，提供清晰的尽可能少的API</li>
<li>小块的代码块</li>
<li>好的表达力（体现在变量名，方法和类的抽象等）</li>
<li>完善错误处理代码（容易被忽略的细节）</li>
<li>一致性（架构设计，变量名，编码规范等）</li>
</ul>
<blockquote>
<p>让营地比你来的时候更加干净</p>
</blockquote>
<p>这一条童子军军规，恰如其分的表达了我的愿望，让项目的代码质量随之时间的推移变得越来越好</p>
<h2 id="2-_有意义的命名">2. 有意义的命名</h2><h4 id="避免误导">避免误导</h4><p>例如: 不要用accountList来指定一组账号，除非它真的是List类型，可以使用accounts或者accountGroup</p>
<h4 id="有意义的区分">有意义的区分</h4><p>例如: </p>
<ol>
<li>使用Product ProductInfo ProductData来表示3个不同类的话是很难区分的，因为Info和Data意义上并没有太大的区别，容易混淆，类似的还有moneyCount和money</li>
<li>nameString真的比name更加清晰吗？</li>
</ol>
<ul>
<li>类名和对象应该是名词，或者名词短语，不应该是动词</li>
<li>方法名应该是动词，或者动词短语</li>
</ul>
<h2 id="3-_函数">3. 函数</h2><ul>
<li>短小</li>
<li>只做一件事（函数中的代码处于同一个抽象层级）</li>
<li>无副作用 只做一件事可以保证无副作用，但是一个无副作用的函数不一定就只做一件事。所以这里不能将无副作用看成是上一点“只做一件事”的结果。副作用：时序性的耦合，顺序依赖。</li>
<li>给函数起一个好名字（包括一致的命名方式）<ul>
<li>动词+关键字（名词）<code>writeFile</code>要优于模糊不清的<code>write</code></li>
</ul>
</li>
<li><p>尽可能少的函数参数（当然,0个是最优的）</p>
<ul>
<li>合理的二元函数 例如笛卡尔点 new Point(10, 10) 这个是自然的秩序，二元是必然的</li>
<li><p>参数较多，就该考虑是否需要抽象为对象 <figure class="highlight"><figcaption><span>x, double y, double radius)``` 可以改写为 ```drawCircle(Point p, double radius)```.将多元函数成功降元。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- &#26631;&#24535;&#21442;&#25968;</span><br></pre></td></tr></table></figure></p>
<p>render(boolean isMobile);</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以改写为两个函数:</span><br></pre></td></tr></table></figure>
<p>renderForMobile()  和 renderForPC()<br>``` </p>
</li>
</ul>
</li>
<li>输出参出  <code>appendFooter</code> 在不查看函数声明的时候, 直觉的会把参数当做输入参数，也就是<code>appendFooter(footer)</code> 但是如果函数声明为<code>void appendFooter(StringBuffer report)</code>,就会恍然大悟了原来是输出参数。优化的方法，可以改写为： <code>report.appendFooter(footer)</code> </li>
<li>错误处理<ul>
<li>抽离try/catch代码块</li>
<li>使用异常的优势<ul>
<li>将异常处理代码从主路径中分离出来(P42-3.9)</li>
</ul>
</li>
</ul>
</li>
<li>Don’t Repeat Yourself (DRY)</li>
</ul>
<blockquote>
<p>语言是程序员设计用来描述系统的。函数是语言的动词，类是语言的名词。大师级程序员把系统当做故事来讲，而不是当做程序来写。他们使用编程语言提供的工具来搭建一种更为丰富，更有表达力的语言，用来讲那个故事。<br>使用清晰精确的语言来讲述一个故事。</p>
</blockquote>
<h2 id="4-_注释">4. 注释</h2><h4 id="注释是一种失败">注释是一种失败</h4><p>无法用代码语言清晰直接表达自己的思路，而需要简洁用其他语言来表达自己的意图。这个时候最好考虑一下是否先改造代码，而不是添加注释。</p>
<h4 id="注释会撒谎">注释会撒谎</h4><p>程序员很难坚持维护注释，导致注释和代码随之时间的推移会慢慢脱节，所以尽可能用代码语言来解释，因为代码是唯一正确的信息源。</p>
<h4 id="值得写的注释">值得写的注释</h4><ul>
<li>法律信息</li>
<li>对意图的解释</li>
<li>警示</li>
<li>TODO</li>
<li>Public API DOC（私有函数是否需要API文档值得商榷）</li>
</ul>
<h4 id="应该删除的注释">应该删除的注释</h4><p>要写就必须写好注释，不要喃喃自语的废话</p>
<ul>
<li>多余的注释</li>
<li>被注释掉的无用代码（这也属于注释的一部分）</li>
</ul>
<h4 id="需要改进的注释">需要改进的注释</h4><ul>
<li>解释的不够详细</li>
<li>可以用代码语言便可解释清楚的注释就不要用注释</li>
</ul>
<h2 id="5-_单元测试">5. 单元测试</h2><p>测试代码和生产代码一样重要，测试代码的可读性甚至要跟强。不好的测试相当于没有测试，因为迟早会因为难以维护而起不到单元测试的作用。</p>
<h4 id="单元测试的编写步骤">单元测试的编写步骤</h4><ol>
<li><strong>Build</strong> 构造测试数据</li>
<li><strong>Operate</strong> 操作测试数据</li>
<li><strong>Check</strong> 检查测试数据</li>
</ol>
<h2 id="6-_对象和数据结构">6. 对象和数据结构</h2><p>隐藏实现并非只是在变量之间放上一个函数层那么简单，隐藏实现关乎抽象。下意识的使用Getter和Setter将变量推向外部（public）,这样的行为是不可取的。每一个公有接口都应该是深思熟虑过的，一遍用户无需了解数据的实现细节就能够操作数据的本体<br>而且简单的使用Getter和Setter是违反The Law of Demeter. </p>
<h2 id="7-_类">7. 类</h2><h4 id="类应该短小">类应该短小</h4><p>可以用代码行数(LOC)来衡量函数的大小，用什么来衡量一个类的大小呢？ <strong>权责！</strong></p>
<ul>
<li><strong>单一权责</strong></li>
<li><p><strong>内聚</strong></p>
<p>  将类中的大函数分割成几个小函数，但是这样子，小函数之间就会通过函数参数进行通信，而将函数参数上升为类的属性变量，就不需要传参数了，但是这样子也意味着类丧失了内聚性，因为出现了越来越多避免传参数而出现的类变量。为了提高这些类的内聚，就会拆分这些类。所以将大函数拆解为小函数，往往也是将类拆分为多个小类的契机。</p>
</li>
<li>类的方法应该细粒度（甚至是原子操作）</li>
</ul>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-暗时间(读书笔记)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/17/暗时间(读书笔记)/" class="article-date">
  	<time datetime="2014-06-16T16:00:00.000Z" itemprop="datePublished">2014-06-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/17/暗时间(读书笔记)/">暗时间 (读书笔记)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>多思考的人心理年龄较大</p>
</blockquote>
<p><strong>思维时间</strong>：推理的过程，或称之为暗时间，吃饭，上厕所，买菜，逛街，都可以变成暗时间</p>
<p><code>投入时间= 时间 * 效率</code></p>
<p>迅速进入状态，并保持状态（思维体力），抗干扰</p>
<h3 id="如何有效的记忆">如何有效的记忆</h3><p>知识表面的细节会迷惑我们的记忆，阻碍我们对知识的运用。意味着我们从既有经验总结知识的时候，应利用适当的抽象来得出适用范围更广的知识，也意味着遇到新问题的时候应该抽象出问题的本质，去除不相干的因素，避免干扰从而有效提取之前抽象出来的知识。</p>
<ul>
<li>定期回顾旧知识</li>
<li>创造回忆的机会<ul>
<li>经常讲给别人听，或者讨论</li>
<li>整理笔记</li>
<li>写书 关联知识，进行知识系统化 </li>
<li>进行知识的实践（虚拟实践和真实实践）</li>
<li>抽象和推广(泛化，推理)</li>
<li>联系自身经历</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果你想真正得到一些知识，最好过滤一下你的信息，否则你只是在别人的知识中得意着</p>
</blockquote>
<h3 id="好的学习习惯">好的学习习惯</h3><h4 id="重视提前积累">重视提前积累</h4><p>设想若干年会做那些事情，需要那些技能和基础，现在就开始准备。提前一年想到，就多了一年的准备时间。每天投入30min，1年之后也会有一定的作用</p>
<h4 id="不忘抬头看路">不忘抬头看路</h4><p>时间有限，要判断一个东西导致值不值得学习。</p>
<h4 id="对新知识的总结">对新知识的总结</h4><h4 id="指定阅读计划">指定阅读计划</h4><h4 id="积累对问题的疑惑">积累对问题的疑惑</h4><p>对一个问题的疑问越多，思考的就越多，一般都会讲带着疑问去看书也是同理</p>
<h4 id="有选择的阅读">有选择的阅读</h4><p>选择好的资料来阅读。而且信息密度低（废话多）的书就可以快速阅读，信息密度高的书需要花多时间阅读<br>阅读的时候这样去切分内容：问题是什么？方案是什么？例子是什么？</p>
<h4 id="利用时间碎片">利用时间碎片</h4><h4 id="看不懂知识的原因">看不懂知识的原因</h4><ol>
<li>看的不够深入</li>
<li>作者讲的不够清晰</li>
<li>涉及到不懂的概念太多</li>
</ol>
<h4 id="对本质知识和非本质知识区分对待">对本质知识和非本质知识区分对待</h4><p>本质知识深入学习（本质知识需要较长时间掌握，如数学，物理，计算机原理等），非本质的用到的读读用户手册就够了</p>
<blockquote>
<p>All Life is Problem-Solving</p>
</blockquote>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/时间管理/">时间管理</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-设计中的设计(读书笔记)" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/08/设计中的设计(读书笔记)/" class="article-date">
  	<time datetime="2014-06-07T16:00:00.000Z" itemprop="datePublished">2014-06-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/08/设计中的设计(读书笔记)/">设计中的设计(读书笔记)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="设计到底是什么？">设计到底是什么？</h2><h4 id="设计源于生活，应用于生活">设计源于生活，应用于生活</h4><p>机械化生产速度惊人，粗糙的产品大量出现，，那些热爱生活的人们对旧日审美的流逝倍感痛心。机械对传统美感的践踏，是人们不能忍受的。<strong>人们的审美意识对工业机制产生的反弹，现代设计的概念由此诞生</strong>。</p>
<h4 id="设计的整合：包豪斯设计运动">设计的整合：包豪斯设计运动</h4><p>经济发展水平导致了生活意识的成熟，开始对设计的关注</p>
<p>美国的经济给与其设计的思想，将设计当做一种经营资源来使用，利用消费者喜新厌旧的心里，通过外观的更新换代来促使消费动机的产生</p>
<p>第二次世界大战之后日本成为世界工厂（规格化，量化的产品），经济虽得以高速发展，却也导致产业设计与文化的分裂。</p>
<p>二十世纪后半叶，美国，欧洲，日本，由于历史背景的不同，经济发展轨迹不同，设计在社会中产生的机能也不一样。但有一点是相同的，主要动力来源都是“经济”。</p>
<blockquote>
<p>将某一种素​​材当成优秀的素材，第一步就是将素材无限纯化。</p>
</blockquote>
<p>类似于API的设计，或者类的抽象，如果要让其成为“优秀素材“（便于使用和继承），就要用心的设计，尽可能的简单和清晰，API接口尽可能的少，而且一致性</p>
<h4 id="日常的设计">日常的设计</h4><blockquote>
<p>熟悉的日常生活也蕴含着无数设计的可能，把熟悉的东西当成未知的领域再度开发，也同样具有创造性</p>
<p>从开始平凡的日常生活中不断开发出创意，才是真正的设计</p>
<p>设计已经深深扎根与生活中</p>
</blockquote>
<h4 id="后现代主义">后现代主义</h4><blockquote>
<p>后现代主义设计师走向老化的象征，后现代充满嬉戏色彩的设计，实际可以看成设计师们开的一个优雅玩笑</p>
</blockquote>
<h4 id="信息时代">信息时代</h4><blockquote>
<p>在不安定的社会基础上不断嫁接不安定的技术体系自然容易出现问题</p>
<p>技术的发展已经远远超出我们作为个体对知识的把握能力，一眼望不到尽头，但现在的思想和教育依然在想着如何追赶上技术的步伐。这是很不妥当的一件事情</p>
</blockquote>
<p>设计作为冷静的求道者的一面？</p>
<blockquote>
<p>就像两个整数之间有无数个小数一样，对于一件事情的看法也是无限的。到目前为止，我们还没有完全发现它们。唤醒和激活它们是“增加认识”的方法，也是丰富物和人之间的紧密关系的途径。</p>
</blockquote>
<p>学院</p>
<ul>
<li>包豪斯学院</li>
<li>乌尔姆设计学院</li>
</ul>
<p>人物</p>
<ul>
<li>沃尔特．格罗庇乌斯(Walter Gropius) 包豪斯的第一任校长</li>
<li>汉斯．梅耶(Hannes Meyer) 包豪斯的第二任校长</li>
<li>莫霍利．纳吉 (laszb Moholy-Nagy)</li>
<li>保罗．克利(Paul klee)</li>
<li>密斯．凡德罗(Ludwing Mies Van der Rohe) 包豪斯的第三任校长</li>
<li>理查德．沃尔曼(Richard saul wurman) 建筑师，平面设计师，信息架构(information architecture)术语的创造者，信息易读实践的先驱，TED会议的创立者。</li>
</ul>
<h2 id="信息建筑的思维方式">信息建筑的思维方式</h2><p><code>外部刺激 + 原有记忆 =&gt; 印象</code></p>
<blockquote>
<p>其最终结果是在观者的脑中，形成一幅由多种刺激组合形成的综合形象。享受这些信息的人是各种感觉的集合体。所以设计师应该对这些信息进行组合，有条不絮的构造信息的集合体，然后还给大家，好让大家进行分门别类的接收。</p>
<p>记忆不是简单的再现过去，而是在接收外部信息的同时，依次被一一唤醒，彼此认证，再充实以新的信息，因此，所谓印象，就是通过感觉器官接收外部刺激，并将刺激与脑中原有的记忆组合，联系而生成的行为</p>
</blockquote>
<p>大脑信息构筑活动的形成，需要感觉器官接收外部的信息，还需要记忆中与外部刺激相关的素材。</p>
<blockquote>
<p>书籍作为一种信息的载体，确实有点过时了…<br>但是信息不仅仅需要被大量的保存和高速的移动。我们需要冷静的观察，思考信息和个人之间的关系，以此来研究信息。以这个标准来评价书籍，用有着合适的重量和厚度，并且手感良好的材料来做信息的载体，显然要比储存在一块记忆卡的信息表现方式更能给人带来良好的使用感和满足感</p>
</blockquote>
<p>以物质的形式来传递信息给自己留下了思考的空间.</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计/">设计</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/读书笔记/">读书笔记</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-由橡皮鸭到Code-Review" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/06/02/由橡皮鸭到Code-Review/" class="article-date">
  	<time datetime="2014-06-01T16:00:00.000Z" itemprop="datePublished">2014-06-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/02/由橡皮鸭到Code-Review/">由橡皮鸭到Code-Review</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="小黄鸭测试法（Rubber_Duck_Debugging）">小黄鸭测试法（Rubber Duck Debugging）</h3><blockquote>
<p>小黄鸭调试法，又称橡皮鸭调试法，黄鸭除虫法（Rubber Duck Debugging）是软件工程中使用的调试代码方法之一。就是在程序的调试、纠错或测试过程中，耐心地向小黄鸭解释每一行程序的作用，以此来激发灵感。– wikipedia</p>
</blockquote>
<p>感觉这是一种又可爱又稍微有点精神分裂感的方法！宅们又扩展出：初音调试法等</p>
<h4 id="过程">过程</h4><ol>
<li>找一个橡皮鸭子。你可以去借，去偷，去抢，去买，自己制作……反正你要搞到一个橡皮鸭子。</li>
<li>把这个橡皮鸭子放在你跟前。标准做法是放在你的桌子上，电脑显示器边，或是键盘边，反正是你的跟前，面朝你。</li>
<li>然后，打开你的源代码。不管是电脑里的还是打印出来的。</li>
<li>对着那只橡皮鸭子，把你写下的所有代码，一行一行地，精心地，向这只橡皮鸭子解释清楚。记住，这是解释，你需要解释出你的想法，思路，观点。不然，那只能算是表述，而不是解释。</li>
<li>当你在向这只始终保持沉默的橡皮鸭子解释的过程中，你会发现你的想法，观点，或思路和实际的代码相偏离了，于是你也就找到了代码中的bug。</li>
<li>找到了BUG，一定要记得感谢一下那个橡皮鸭子哦。</li>
</ol>
<p>而code-review就是小黄鸭的进化版，因为将不会说话可爱的小黄鸭变成会反馈的人。</p>
<h3 id="Code_Review">Code Review</h3><p>在<a href="http://coolshell.cn/articles/1302.html" target="_blank" rel="external">Code Review中的几个提示</a>这篇文章中提及到code-review（下面简称为CR）的作用：</p>
<ul>
<li>传递知识，同时方便日后维护代码</li>
<li>确认实际和实现是简单和清楚的</li>
<li>相互学习，相互帮助，增强团队凝聚力</li>
</ul>
<p>之前自己所在的上一个团队里面有队员提出CR的想法，但是得到负面的反馈会更多，大家直觉的回答（不排除有些人有过往的经验）是： </p>
<ul>
<li>太耗时间</li>
<li>怕对其他人造成伤害，比较程序员都是比较自负的</li>
</ul>
<p>如果是小组会议的形式，这个是会比较耗时的，但是可以采取非正式短时间的CR，对于“伤害他人”的这个看法，如果保持一个正面开放的态度，才是有助于自己学习成长的。程序员自负这种简单的论调太过没有说服力了。</p>
<p>而在《Code Review中的几个提示》中提及的几点觉得非常有道理：</p>
<ul>
<li>循序渐进的CR，而不是项目接近完成的时候再进行</li>
<li>CR不需要太正式，要短</li>
<li>积极正面的态度</li>
<li>CR主要不是承担保证代码风格，发现代码错误这样的职责</li>
</ul>
<h3 id="参考">参考</h3><ol>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95" target="_blank" rel="external">wiki/小黄鸭调试法</a></li>
<li><a href="http://coolshell.cn/articles/1218.html" target="_blank" rel="external">简单实用的Code Review工具</a></li>
<li><a href="http://coolshell.cn/articles/1302.html" target="_blank" rel="external">Code Review中的几个提示</a></li>
<li><a href="http://blog.csdn.net/haoel/article/details/4914403" target="_blank" rel="external">橡皮鸭程序调试法</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/测试/">测试</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-浏览器关键时间点" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/20/浏览器关键时间点/" class="article-date">
  	<time datetime="2014-05-19T16:00:00.000Z" itemprop="datePublished">2014-05-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/20/浏览器关键时间点/">什么是浏览器关键时间点？</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="http://www.w3.org/TR/navigation-timing/timing-overview.png" alt="enter image description here"></p>
<p>注明: 图片引用自 <a href="http://www.w3.org/TR/navigation-timing/" target="_blank" rel="external">W3C</a></p>
<h3 id="TTFB(Time_to_First_Byte)">TTFB(Time to First Byte)</h3><p>指从客户端开始和服务端交互到服务端开始向客户端浏览器传输数据的时间（包括DNS、socket连接和请求响应时间），是能够反映服务端响应速度的重要指标 </p>
<p>优化：优化DNS查询，使用CDN，提早Flush，添加周期头等</p>
<h3 id="TTDD(Time_To_Document_Download)">TTDD(Time To Document Download)</h3><p>从服务器加载HTML文档的时间</p>
<h3 id="TTHE(Time_To_Head_End)">TTHE(Time To Head End)</h3><p>HTML文档头部解析完成所需要的时间 </p>
<h3 id="TTSR(Time_To_Start_Render)">TTSR(Time To Start Render)</h3><p>定义：浏览器开始渲染的时间，从用户角度出发则可以定义为用户在页面上看到的第一个内容的时间。 即TTSR越短，用户越早浏览器中的内容，心理上的等待时间会越短。</p>
<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Time</span> To <span class="built_in">Start</span> Render: TTSR = TTFB + TTDD + TTHE</span><br></pre></td></tr></table></figure>
<p>其中 <code>TTFB</code>, <code>TTDD</code>,<code>TTHE</code> 在前面提到过了，可以查看前面的介绍；</p>
<p>通过以上公式可以看到<code>TTSR</code>时长主要受以下因素影响， 而且这些因素是开发人员可以控制的，可以通过优化来缩短 <code>TTSR</code> 时长；</p>
<ol>
<li>服务器响应时间</li>
<li>HTML文档的大小</li>
<li>Head中资源使用情况, 是否有脚本阻塞了页面的解析</li>
</ol>
<h3 id="与DOM相关的事件">与DOM相关的事件</h3><p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/dom-navtiming.png" alt="enter image description here"></p>
<blockquote>
<ul>
<li>domLoading：这是整个过程开始的时间戳，浏览器开始解析 HTML 文档第一批收到的字节 document.</li>
<li>domInteractive：标记浏览器完成解析并且所有 HTML 和 DOM 构建完毕的时间点。</li>
<li>domContentLoaded：标记 DOM 准备就绪并且没有样式表阻碍 JavaScript 执行的时间点 - 意味着我们可以开始构建呈现树了。<ul>
<li>很多 JavaScript 框架等待此事件发生后，才开始执行它们自己的逻辑。因此，浏览器会通过捕获 EventStart 和 EventEnd 时间戳，跟踪执行逻辑所需的时间。</li>
</ul>
</li>
<li>domComplete： 顾名思义，所有的处理完成，网页上所有资源（图片等） 下载完成 - 即加载旋转图标停止旋转。</li>
<li>loadEvent：作为每个网页加载的最后一步，浏览器会触发onLoad事件，以便触发附加的应用逻辑。所以onload事件会在 domInteractive、domContentLoaded 和 domComplete 之后触发</li>
</ul>
</blockquote>
<p><code>DomContentLoaded</code> 通常标记 [DOM 和 CSSOM 都准备就绪] 的时间 , 通俗的讲就是：页面解析完成的时间，在高级浏览器里有对应的DOM事件 - <code>DOMContentLoaded</code>，Firefox官方的解析如下：</p>
<blockquote>
<p>Fired at the page’s Document object when parsing of the document is finished. By the time this event fires, the page’s DOM is ready, but the referenced stylesheets, images, and subframesmay not be done loading; use the “load” event to detect a fully-loaded page.</p>
</blockquote>
<p><code>TTSR</code>指标直接决定着用户对页面速度的体验，与此不同，DOM Ready指标并不直接影响感官体验，往往影响的是交互功能何时可用。为何影响的是交互呢？由于<code>DOMContentLoaded</code>事件触发时是所有DOM节点可以进行操作的时候，比如添加事件、增删改节点等，因此用Javascript实现的一些交互功能往往会在DOMContentLoaded事件中去初始化，也只有在<code>DOMContentLoaded</code>事件触发后这项功能才可用。  </p>
<p><img src="https://developer.chrome.com/devtools/docs/network-files/dom-lines.png" alt="enter image description here"></p>
<p>注明：图片来自google developer</p>
<p>这里还要提及的是 <code>DomContentLoaded</code> , <code>DomComplete</code> 这两个时间的差别，网页的Dom内容加载并解析完成时会触发<code>DomContentLoaded</code>，而<code>DomComplete</code>是在网页的资源（css,image等）加载完成后才触发。英文文档原文如下：</p>
<blockquote>
<p> The DOMContentLoaded event is fired when all of the page’s DOM content has been loaded and parsed. The load event is fired once all of the document’s resources (images and CSS files, and so forth) have been fully loaded.</p>
</blockquote>
<h3 id="TTDR_(Time_To_Dom_Ready_)">TTDR (Time To Dom Ready )</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">TTDR </span>=<span class="string"> TTSR + TTDC + TTST</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>TTSR</code>(Time To Start Render)：浏览器开始渲染的时间</li>
<li><code>TTDC</code>(Time To Dom Created)：DOM树创建所耗时间</li>
<li><code>TTST</code>(Time To Script)：BODY中所有脚本加载和执行的时间</li>
</ul>
<p>通过以上公式可以看到Start Render主要受以下因素影响:</p>
<ol>
<li>DOM结构的复杂程度</li>
<li>BODY中脚本运行时间</li>
</ol>
<p>通过对一些实际监控数据的分析得出，在一个通过正常方式加载脚本的页面中，脚本的加载和执行时间往往能占DOM Ready时间的50%左右，由此可见脚本的使用对DOM Ready指标的影响如何的显著！因此，对DOM Ready指标的优化也应该着重从js脚本的使用入手。 </p>
<p>当然，随着硬件性能越来越高，脚本的执行时间对于页面加载速度的影响会越来越少；但是，如果有构建一个60fps的web应用，细节往往是非常重要的</p>
<h3 id="TTI(time_to_interact)">TTI(time to interact)</h3><p>TTI(Time To Interact)指的是页面可交互的时间。页面中的交互包括很多方面，例如点击一个链接、点击一个搜索按钮都属于页面交互的范畴，但是对于衡量性能的TTI则主要指核心功能可以交互的时间。核心功能的定义则是随着页面的不同而不同，例如对于百度首页而言，最为关键的就是搜索框出现的时间、而对于一些购物网站的商品详情页最关键的是购买功能可用和描述出现的时间。而目前的实际情况，TTI大都等于DOM Ready时间，因为不论交互功能是否重要，相关的Javascript都会在DOM Ready后才进行初始化和绑定，而实际上TTI是可以更早的。  </p>
<p>通过TTI的定义可以知道，TTI的长短对于用户体验的影响是十分重要的，它影响着用户对核心功能的使用。</p>
<ol>
<li>Start Render时间 - 只有内容开始渲染了，接下来才有可能提供可交互的界面，因此渲染时间的快与慢会直接影响TTI时间。</li>
<li>核心功能相关HTML元素的显示时间 ， 决定着核心功能对用户可见的时间</li>
<li>提供用户交互的JS脚本什么时候执行完成 ， 决定着核心Javascript功能可交互的时间</li>
</ol>
<p>在HTML5应用中，JS模板引擎的使用是非常普遍的，这个使用得好可以提高TTI时间，使用得不好，会比没有使用模板引擎而是通过后端模板引擎渲染的页面更慢。客户端使用JS模板引擎进行渲染的过程必须知会用户，然用户不至于见到一个空白页面，这个在我之前做过的一个项目，UC视频就是一个很好的反例。</p>
<h3 id="参考：">参考：</h3><ol>
<li><a href="http://www.cnblogs.com/onflying/archive/2013/04/23/3037789.html" target="_blank" rel="external">http://www.cnblogs.com/onflying/archive/2013/04/23/3037789.html</a> </li>
<li><a href="http://www.w3.org/2010/webperf/" target="_blank" rel="external">http://www.w3.org/2010/webperf/</a>  </li>
<li><a href="https://developer.mozilla.org/en-US/docs/Navigation_timing" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Navigation_timing</a> </li>
<li><a href="http://nunumick.me/blog/2011/02/23/web-page-speed-metrics.html" target="_blank" rel="external">http://nunumick.me/blog/2011/02/23/web-page-speed-metrics.html</a>  </li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%A7%E7%8E%87" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%B8%A7%E7%8E%87</a>  </li>
<li><a href="http://addyosmani.com/blog/performance-optimisation-with-timeline-profiles/" target="_blank" rel="external">http://addyosmani.com/blog/performance-optimisation-with-timeline-profiles/</a> </li>
<li><a href="http://blog.chromium.org/2012/11/build-smoother-web-apps-with-chrome.html" target="_blank" rel="external">http://blog.chromium.org/2012/11/build-smoother-web-apps-with-chrome.html</a> </li>
<li><a href="http://www.w3.org/TR/navigation-timing/" target="_blank" rel="external">http://www.w3.org/TR/navigation-timing/</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/network" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/network</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/前端性能优化/">前端性能优化</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/前端开发/">前端开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-命令空間與模塊加載器的異同" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/07/命令空間與模塊加載器的異同/" class="article-date">
  	<time datetime="2014-05-06T16:00:00.000Z" itemprop="datePublished">2014-05-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/07/命令空間與模塊加載器的異同/">命令空间与模块加载器的异同</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言">前言</h3><p>近期接手了一個項目，前端這一塊沒有採用模塊加載器（Seajs或者Requirejs）來進行模塊化，而是僅僅採用命名空間這種形式。由於一開始做前端開發就已經習慣了使用模塊化加載器這種工具來進行模塊化開發，一時間覺得命令空間這種組織代碼的形式就像一條打了很多補丁的褲子，可以穿，但是很丑。所以具體找一找到底丑在哪裡，已經模塊加載器的優勢。</p>
<p>首先找出lifesinger的一篇舊文<a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="external">「前端模塊化開發的價值」</a>， 其中介紹過這兩種方式的優劣</p>
<blockquote>
<ol>
<li>模块的版本管理。通过别名等配置，配合构建工具，可以比较轻松地实现模块的版本管理。</li>
<li>提高可维护性。模块化可以让每个文件的职责单一，非常有利于代码的维护。Sea.js 还提供了 nocache、debug 等插件，拥有在线调试等功能，能比较明显地提升效率。</li>
<li>前端性能优化。Sea.js 通过异步加载模块，这对页面性能非常有益。Sea.js 还提供了 combo、flush 等插件，配合服务端，可以很好地对页面性能进行调优。</li>
<li>跨环境共享模块。CMD 模块定义规范与 Node.js 的模块规范非常相近。通过 Sea.js 的 Node.js 版本，可以很方便实现模块的跨服务器和浏览器共享。</li>
</ol>
</blockquote>
<p>//Todo</p>
<h3 id="參考">參考</h3><ol>
<li><a href="http://chaoskeh.com/blog/why-seajs.html" target="_blank" rel="external">Why Seajs</a></li>
<li><a href="https://github.com/seajs/seajs/issues/547" target="_blank" rel="external">前端模塊化開發的價值</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/模块化/">模块化</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/前端开发/">前端开发</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-html5-Drag-and-drop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2014/05/06/html5-Drag-and-drop/" class="article-date">
  	<time datetime="2014-05-05T16:00:00.000Z" itemprop="datePublished">2014-05-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/05/06/html5-Drag-and-drop/">Drag 和 Drop接口的使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Draggable_Attribute">Draggable Attribute</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">draggable</span>=<span class="value">"true"</span> <span class="attribute">ondragstart</span>=<span class="value">"event.dataTransfer.setData('text/plain', 'This text may be dragged')"</span>&gt;</span></span><br><span class="line">  This text <span class="tag">&lt;<span class="title">strong</span>&gt;</span>may<span class="tag">&lt;/<span class="title">strong</span>&gt;</span> be dragged.</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>The draggable attribute is set to true, so this element becomes draggable. If this attribute was omitted or set to false, the element would not be dragged and instead the text would be selected. </p>
<h3 id="ondragstart">ondragstart</h3><h3 id="Setting_the_drag_feedback_image">Setting the drag feedback image</h3><h3 id="dragEffect">dragEffect</h3><p>dropEffect的取值</p>
<ul>
<li>copy: A copy of the source item is made at the new location.</li>
<li>move: An item is moved to a new location.</li>
<li>link: A link is established to the source at the new location.</li>
<li>none: The item may not be dropped.</li>
</ul>
<h3 id="effectAllowed">effectAllowed</h3><p>Specifies the effects that are allowed for this drag. You may set this in the dragstart event to set the desired effects for the source, and within the dragenter and dragover events to set the desired effects for the target. The value is not used for other events.</p>
<h3 id="setData和getData">setData和getData</h3><p>The getData method takes one argument, the type of data to retrieve. It will return the string value that was set when the setData was called at the beginning of the drag operation. An empty string will be returned if data of that type does not exist</p>
<h3 id="Specifying_Drop_Targets">Specifying Drop Targets</h3><p>If you want to allow a drop, you must prevent the default handling by cancelling the event. You can do this either by returning false from an attribute-defined event listener, or by calling the event’s event.preventDefault method.</p>
<p>涉及到的事件類型：</p>
<ul>
<li>dragstart</li>
<li>drag</li>
<li>dragenter 進入drop區域</li>
<li>dragover</li>
<li>dragleave</li>
<li>drop</li>
<li>dragend : Once the drag is complete, a dragend event is fired at the source of the drag (the same element that received the dragstart event)</li>
</ul>
<h4 id="處理drop事件">處理drop事件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onDrop</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//通過getData取得drag要傳輸的數據</span></span><br><span class="line">  <span class="keyword">var</span> data = event.dataTransfer.getData(<span class="string">"text/plain"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意，這裡event.target是要drop的目標對象，而不是被drag的對象</span></span><br><span class="line">  event.target.textContent = data;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//防止瀏覽器執行默認的操作，例如drag一個A鏈接，瀏覽器會打開這個A鏈接</span></span><br><span class="line">  event.preventDefault();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Drop_Effect">Drop Effect</h3><p>可以結合dragenter, dragleave, dragend, drop等事件來實現負責的drop效果</p>
<h3 id="例子">例子</h3><ul>
<li><a href="http://jsfiddle.net/cL3SY/4/" target="_blank" rel="external">例子1</a></li>
<li><a href="http://jsfiddle.net/pfKqQ/2/" target="_blank" rel="external">例子2</a></li>
<li><a href="http://html5demos.com/drag" target="_blank" rel="external">html5 demos上的drag例子</a></li>
</ul>
<h3 id="参考">参考</h3><ol>
<li><a href="https://developer.mozilla.org/en-US/docs/DragDrop/Recommended_Drag_Types" target="_blank" rel="external">MDN-Drag-drop Rcommended Drag Types</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer" target="_blank" rel="external">DataTransfer</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/DragDrop/Drag_and_Drop" target="_blank" rel="external">Drag and drop basics</a></li>
<li><a href="http://www.html5rocks.com/en/tutorials/dnd/basics/" target="_blank" rel="external">09.2010 Native HTML5 Drag and Drop By Eric Bidelman</a></li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html5/">html5</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/html/">html</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Andrew Zhang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>